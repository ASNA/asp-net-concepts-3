<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>bootstrap.bundle.js</title>
  <link rel="stylesheet" href="..\..\..\..\pycco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div class='section'>
    <div class='docs'><h1>bootstrap.bundle.js</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      <p>!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span></span>  <span class="o">*</span><span class="err">/</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nb">global</span><span class="p">,</span> <span class="nx">factory</span><span class="p">)</span> <span class="p">{</span>
  <span class="ow">typeof</span> <span class="nx">exports</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">&amp;&amp;</span> <span class="ow">typeof</span> <span class="nx">module</span> <span class="o">!==</span> <span class="s1">&#39;undefined&#39;</span> <span class="o">?</span> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">factory</span><span class="p">()</span> <span class="o">:</span>
  <span class="ow">typeof</span> <span class="nx">define</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">define</span><span class="p">.</span><span class="nx">amd</span> <span class="o">?</span> <span class="nx">define</span><span class="p">(</span><span class="nx">factory</span><span class="p">)</span> <span class="o">:</span>
  <span class="p">(</span><span class="nb">global</span> <span class="o">=</span> <span class="ow">typeof</span> <span class="nb">globalThis</span> <span class="o">!==</span> <span class="s1">&#39;undefined&#39;</span> <span class="o">?</span> <span class="nb">globalThis</span> <span class="o">:</span> <span class="nb">global</span> <span class="o">||</span> <span class="nx">self</span><span class="p">,</span> <span class="nb">global</span><span class="p">.</span><span class="nx">bootstrap</span> <span class="o">=</span> <span class="nx">factory</span><span class="p">());</span>
<span class="p">})(</span><span class="k">this</span><span class="p">,</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="s1">&#39;use strict&#39;</span><span class="p">;</span>

  <span class="cm">/**</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">   * Bootstrap (v5.1.3): util/index.js</span>
<span class="cm">   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">   * Public Util Api</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   * Trick to restart an element&#39;s animation</span>
<span class="cm">   *</span>
<span class="cm">   * @param {HTMLElement} element</span>
<span class="cm">   * @return void</span>
<span class="cm">   *</span>
<span class="cm">   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation</span>
<span class="cm">//DIVIDER</span>

<span class="cm">      if ($) {</span>
<span class="cm">        const name = plugin.NAME;</span>
<span class="cm">        const JQUERY_NO_CONFLICT = $.fn[name];</span>
<span class="cm">        $.fn[name] = plugin.jQueryInterface;</span>
<span class="cm">        $.fn[name].Constructor = plugin;</span>

<span class="cm">        $.fn[name].noConflict = () =&gt; {</span>
<span class="cm">          $.fn[name] = JQUERY_NO_CONFLICT;</span>
<span class="cm">          return plugin.jQueryInterface;</span>
<span class="cm">        };</span>
<span class="cm">      }</span>
<span class="cm">    });</span>
<span class="cm">  };</span>

<span class="cm">  const execute = callback =&gt; {</span>
<span class="cm">    if (typeof callback === &#39;function&#39;) {</span>
<span class="cm">      callback();</span>
<span class="cm">    }</span>
<span class="cm">  };</span>

<span class="cm">  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) =&gt; {</span>
<span class="cm">    if (!waitForTransition) {</span>
<span class="cm">      execute(callback);</span>
<span class="cm">      return;</span>
<span class="cm">    }</span>

<span class="cm">    const durationPadding = 5;</span>
<span class="cm">    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;</span>
<span class="cm">    let called = false;</span>

<span class="cm">    const handler = ({</span>
<span class="cm">      target</span>
<span class="cm">    }) =&gt; {</span>
<span class="cm">      if (target !== transitionElement) {</span>
<span class="cm">        return;</span>
<span class="cm">      }</span>

<span class="cm">      called = true;</span>
<span class="cm">      transitionElement.removeEventListener(TRANSITION_END, handler);</span>
<span class="cm">      execute(callback);</span>
<span class="cm">    };</span>

<span class="cm">    transitionElement.addEventListener(TRANSITION_END, handler);</span>
<span class="cm">    setTimeout(() =&gt; {</span>
<span class="cm">      if (!called) {</span>
<span class="cm">        triggerTransitionEnd(transitionElement);</span>
<span class="cm">      }</span>
<span class="cm">    }, emulatedDuration);</span>
<span class="cm">  };</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   */</span>


  <span class="kd">const</span> <span class="nx">getNextActiveElement</span> <span class="o">=</span> <span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">activeElement</span><span class="p">,</span> <span class="nx">shouldGetNext</span><span class="p">,</span> <span class="nx">isCycleAllowed</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">activeElement</span><span class="p">);</span> <span class="c1">// if the element does not exist in the list return an element depending on the direction and if cycle is allowed</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">===</span> <span class="o">-</span><span class="mf">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">list</span><span class="p">[</span><span class="o">!</span><span class="nx">shouldGetNext</span> <span class="o">&amp;&amp;</span> <span class="nx">isCycleAllowed</span> <span class="o">?</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mf">1</span> <span class="o">:</span> <span class="mf">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">listLength</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="nx">index</span> <span class="o">+=</span> <span class="nx">shouldGetNext</span> <span class="o">?</span> <span class="mf">1</span> <span class="o">:</span> <span class="o">-</span><span class="mf">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">isCycleAllowed</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">index</span> <span class="o">=</span> <span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="nx">listLength</span><span class="p">)</span> <span class="o">%</span> <span class="nx">listLength</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">list</span><span class="p">[</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">listLength</span> <span class="o">-</span> <span class="mf">1</span><span class="p">))];</span>
  <span class="p">};</span>

  <span class="cm">/**</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">   * Bootstrap (v5.1.3): dom/event-handler.js</span>
<span class="cm">   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   * ------------------------------------------------------------------------</span>
<span class="cm">   * Constants</span>
<span class="cm">   * ------------------------------------------------------------------------</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   * ------------------------------------------------------------------------</span>
<span class="cm">   * Private methods</span>
<span class="cm">   * ------------------------------------------------------------------------</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">   * Bootstrap (v5.1.3): dom/data.js</span>
<span class="cm">   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   * ------------------------------------------------------------------------</span>
<span class="cm">   * Constants</span>
<span class="cm">   * ------------------------------------------------------------------------</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">   * Bootstrap (v5.1.3): base-component.js</span>
<span class="cm">   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)</span>
<span class="cm">   * --------------------------------------------------------------------------</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   * ------------------------------------------------------------------------</span>
<span class="cm">   * Constants</span>
<span class="cm">   * ------------------------------------------------------------------------</span>
<span class="cm">//DIVIDER</span>


<span class="cm">    static getInstance(element) {</span>
<span class="cm">      return Data.get(getElement(element), this.DATA_KEY);</span>
<span class="cm">    }</span>

<span class="cm">    static getOrCreateInstance(element, config = {}) {</span>
<span class="cm">      return this.getInstance(element) || new this(element, typeof config === &#39;object&#39; ? config : null);</span>
<span class="cm">    }</span>

<span class="cm">    static get VERSION() {</span>
<span class="cm">      return VERSION;</span>
<span class="cm">    }</span>

<span class="cm">    static get NAME() {</span>
<span class="cm">      throw new Error(&#39;You have to implement the static method &quot;NAME&quot;, for each component!&#39;);</span>
<span class="cm">    }</span>

<span class="cm">    static get DATA_KEY() {</span>
<span class="cm">      return `bs.${this.NAME}`;</span>
<span class="cm">    }</span>

<span class="cm">    static get EVENT_KEY() {</span>
<span class="cm">      return `.${this.DATA_KEY}`;</span>
<span class="cm">    }</span>

<span class="cm">  }</span>
<span class="cm">//DIVIDER</span>
<span class="cm">   */</span>

  <span class="kd">const</span> <span class="nx">enableDismissTrigger</span> <span class="o">=</span> <span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">method</span> <span class="o">=</span> <span class="s1">&#39;hide&#39;</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">clickEvent</span> <span class="o">=</span> <span class="sb">`click.dismiss</span><span class="si">${</span><span class="nx">component</span><span class="p">.</span><span class="nx">EVENT_KEY</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">component</span><span class="p">.</span><span class="nx">NAME</span><span class="p">;</span>
    <span class="nx">EventHandler</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="nb">document</span><span class="p">,</span> <span class="nx">clickEvent</span><span class="p">,</span> <span class="sb">`[data-bs-dismiss=&quot;</span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">&quot;]`</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;AREA&#39;</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">tagName</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">isDisabled</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="kd">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">getElementFromSelector</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">closest</span><span class="p">(</span><span class="sb">`.</span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">component</span><span class="p">.</span><span class="nx">getOrCreateInstance</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span> <span class="c1">// Method argument is left, for Alert and only, as it doesn&#39;t implement the &#39;hide&#39; method</span>

      <span class="nx">instance</span><span class="p">[</span><span class="nx">method</span><span class="p">]();</span>
    <span class="p">});</span>
  <span class="p">};</span>

  <span class="err">/**</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">alert</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p>const MAX_UID = 1000000;
  const MILLISECONDS_MULTIPLIER = 1000;
  const TRANSITION_END = &lsquo;transitionend&rsquo;; // Shoutout AngusCroll (https://goo.gl/pxwQGp)</p>
<p>const toType = obj =&gt; {
 if (obj === null || obj === undefined) {
   return <code>${obj}</code>;
 }</p>
<p>return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      <p>const getUID = prefix =&gt; {
 do {
   prefix += Math.floor(Math.random() * MAX_UID);
 } while (document.getElementById(prefix));</p>
<p>return prefix;
  };</p>
<p>const getSelector = element =&gt; {
 let selector = element.getAttribute(&lsquo;data-bs-target&rsquo;);</p>
<p>if (!selector || selector === &lsquo;#&rsquo;) {
   let hrefAttr = element.getAttribute(&lsquo;href&rsquo;); // The only valid content that could double as a selector are IDs or classes,
   // so everything starting with <code>#</code> or <code>.</code>. If a &ldquo;real&rdquo; URL is used as the selector,
   // <code>document.querySelector</code> will rightfully complain it is invalid.
   // See https://github.com/twbs/bootstrap/issues/32273</p>
<p>if (!hrefAttr || !hrefAttr.includes(&lsquo;#&rsquo;) &amp;&amp; !hrefAttr.startsWith(&lsquo;.&rsquo;)) {
     return null;
   } // Just in case some CMS puts out a full URL with the anchor appended</p>
<p>if (hrefAttr.includes(&lsquo;#&rsquo;) &amp;&amp; !hrefAttr.startsWith(&lsquo;#&rsquo;)) {
     hrefAttr = <code>#${hrefAttr.split('#')[1]}</code>;
   }</p>
<p>selector = hrefAttr &amp;&amp; hrefAttr !== &lsquo;#&rsquo; ? hrefAttr.trim() : null;
 }</p>
<p>return selector;
  };</p>
<p>const getSelectorFromElement = element =&gt; {
 const selector = getSelector(element);</p>
<p>if (selector) {
   return document.querySelector(selector) ? selector : null;
 }</p>
<p>return null;
  };</p>
<p>const getElementFromSelector = element =&gt; {
 const selector = getSelector(element);
 return selector ? document.querySelector(selector) : null;
  };</p>
<p>const getTransitionDurationFromElement = element =&gt; {
 if (!element) {
   return 0;
 } // Get transition-duration of the element</p>
<p>let {
   transitionDuration,
   transitionDelay
 } = window.getComputedStyle(element);
 const floatTransitionDuration = Number.parseFloat(transitionDuration);
 const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found</p>
<p>if (!floatTransitionDuration &amp;&amp; !floatTransitionDelay) {
   return 0;
 } // If multiple durations are defined, take the first</p>
<p>transitionDuration = transitionDuration.split(&lsquo;,&rsquo;)[0];
 transitionDelay = transitionDelay.split(&lsquo;,&rsquo;)[0];
 return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };</p>
<p>const triggerTransitionEnd = element =&gt; {
 element.dispatchEvent(new Event(TRANSITION_END));
  };</p>
<p>const isElement$1 = obj =&gt; {
 if (!obj || typeof obj !== &lsquo;object&rsquo;) {
   return false;
 }</p>
<p>if (typeof obj.jquery !== &lsquo;undefined&rsquo;) {
   obj = obj[0];
 }</p>
<p>return typeof obj.nodeType !== &lsquo;undefined&rsquo;;
  };</p>
<p>const getElement = obj =&gt; {
 if (isElement$1(obj)) {
   // it&rsquo;s a jQuery object or a node element
   return obj.jquery ? obj[0] : obj;
 }</p>
<p>if (typeof obj === &lsquo;string&rsquo; &amp;&amp; obj.length &gt; 0) {
   return document.querySelector(obj);
 }</p>
<p>return null;
  };</p>
<p>const typeCheckConfig = (componentName, config, configTypes) =&gt; {
 Object.keys(configTypes).forEach(property =&gt; {
   const expectedTypes = configTypes[property];
   const value = config[property];
   const valueType = value &amp;&amp; isElement$1(value) ? &lsquo;element&rsquo; : toType(value);</p>
<p>if (!new RegExp(expectedTypes).test(valueType)) {
     throw new TypeError(<code>${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".</code>);
   }
 });
  };</p>
<p>const isVisible = element =&gt; {
 if (!isElement$1(element) || element.getClientRects().length === 0) {
   return false;
 }</p>
<p>return getComputedStyle(element).getPropertyValue(&lsquo;visibility&rsquo;) === &lsquo;visible&rsquo;;
  };</p>
<p>const isDisabled = element =&gt; {
 if (!element || element.nodeType !== Node.ELEMENT_NODE) {
   return true;
 }</p>
<p>if (element.classList.contains(&lsquo;disabled&rsquo;)) {
   return true;
 }</p>
<p>if (typeof element.disabled !== &lsquo;undefined&rsquo;) {
   return element.disabled;
 }</p>
<p>return element.hasAttribute(&lsquo;disabled&rsquo;) &amp;&amp; element.getAttribute(&lsquo;disabled&rsquo;) !== &lsquo;false&rsquo;;
  };</p>
<p>const findShadowRoot = element =&gt; {
 if (!document.documentElement.attachShadow) {
   return null;
 } // Can find the shadow root otherwise it&rsquo;ll return the document</p>
<p>if (typeof element.getRootNode === &lsquo;function&rsquo;) {
   const root = element.getRootNode();
   return root instanceof ShadowRoot ? root : null;
 }</p>
<p>if (element instanceof ShadowRoot) {
   return element;
 } // when we don&rsquo;t find a shadow root</p>
<p>if (!element.parentNode) {
   return null;
 }</p>
<p>return findShadowRoot(element.parentNode);
  };</p>
<p>const noop = () =&gt; {};
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-3'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-3'>#</a>
      </div>
      <p>const reflow = element =&gt; {
 // eslint-disable-next-line no-unused-expressions
 element.offsetHeight;
  };</p>
<p>const getjQuery = () =&gt; {
 const {
   jQuery
 } = window;</p>
<p>if (jQuery &amp;&amp; !document.body.hasAttribute(&lsquo;data-bs-no-jquery&rsquo;)) {
   return jQuery;
 }</p>
<p>return null;
  };</p>
<p>const DOMContentLoadedCallbacks = [];</p>
<p>const onDOMContentLoaded = callback =&gt; {
 if (document.readyState === &lsquo;loading&rsquo;) {
   // add listener on the first call when the document is in loading state
   if (!DOMContentLoadedCallbacks.length) {
     document.addEventListener(&lsquo;DOMContentLoaded&rsquo;, () =&gt; {
       DOMContentLoadedCallbacks.forEach(callback =&gt; callback());
     });
   }</p>
<p>DOMContentLoadedCallbacks.push(callback);
 } else {
   callback();
 }
  };</p>
<p>const isRTL = () =&gt; document.documentElement.dir === &lsquo;rtl&rsquo;;</p>
<p>const defineJQueryPlugin = plugin =&gt; {
 onDOMContentLoaded(() =&gt; {
   const $ = getjQuery();
istanbul ignore if
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Data</span> <span class="nx">Api</span> <span class="nx">implementation</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-4'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-4'>#</a>
      </div>
      <ul>
<li>Return the previous/next element of a list.
 *</li>
<li>@param {array} list    The list of elements</li>
<li>@param activeElement   The active element</li>
<li>@param shouldGetNext   Choose to get next or previous element</li>
<li>@param isCycleAllowed</li>
<li>@return {Element|elem} The proper element</li>
</ul>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Alert</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-5'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-5'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">button</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-6'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-6'>#</a>
      </div>
      <p>const namespaceRegex = /[^.]<em>(?=..</em>).|.<em>/;
  const stripNameRegex = /..</em>/;
  const stripUidRegex = /::\d+$/;
  const eventRegistry = {}; // Events storage</p>
<p>let uidEvent = 1;
  const customEvents = {
 mouseenter: &lsquo;mouseover&rsquo;,
 mouseleave: &lsquo;mouseout&rsquo;
  };
  const customEventsRegex = /^(mouseenter|mouseleave)/i;
  const nativeEvents = new Set([&lsquo;click&rsquo;, &lsquo;dblclick&rsquo;, &lsquo;mouseup&rsquo;, &lsquo;mousedown&rsquo;, &lsquo;contextmenu&rsquo;, &lsquo;mousewheel&rsquo;, &lsquo;DOMMouseScroll&rsquo;, &lsquo;mouseover&rsquo;, &lsquo;mouseout&rsquo;, &lsquo;mousemove&rsquo;, &lsquo;selectstart&rsquo;, &lsquo;selectend&rsquo;, &lsquo;keydown&rsquo;, &lsquo;keypress&rsquo;, &lsquo;keyup&rsquo;, &lsquo;orientationchange&rsquo;, &lsquo;touchstart&rsquo;, &lsquo;touchmove&rsquo;, &lsquo;touchend&rsquo;, &lsquo;touchcancel&rsquo;, &lsquo;pointerdown&rsquo;, &lsquo;pointermove&rsquo;, &lsquo;pointerup&rsquo;, &lsquo;pointerleave&rsquo;, &lsquo;pointercancel&rsquo;, &lsquo;gesturestart&rsquo;, &lsquo;gesturechange&rsquo;, &lsquo;gestureend&rsquo;, &lsquo;focus&rsquo;, &lsquo;blur&rsquo;, &lsquo;change&rsquo;, &lsquo;reset&rsquo;, &lsquo;select&rsquo;, &lsquo;submit&rsquo;, &lsquo;focusin&rsquo;, &lsquo;focusout&rsquo;, &lsquo;load&rsquo;, &lsquo;unload&rsquo;, &lsquo;beforeunload&rsquo;, &lsquo;resize&rsquo;, &lsquo;move&rsquo;, &lsquo;DOMContentLoaded&rsquo;, &lsquo;readystatechange&rsquo;, &lsquo;error&rsquo;, &lsquo;abort&rsquo;, &lsquo;scroll&rsquo;]);
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-7'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-7'>#</a>
      </div>
      <p>function getUidEvent(element, uid) {
 return uid &amp;&amp; <code>${uid}::${uidEvent++}</code> || element.uidEvent || uidEvent++;
  }</p>
<p>function getEvent(element) {
 const uid = getUidEvent(element);
 element.uidEvent = uid;
 eventRegistry[uid] = eventRegistry[uid] || {};
 return eventRegistry[uid];
  }</p>
<p>function bootstrapHandler(element, fn) {
 return function handler(event) {
   event.delegateTarget = element;</p>
<p>if (handler.oneOff) {
     EventHandler.off(element, event.type, fn);
   }</p>
<p>return fn.apply(element, [event]);
 };
  }</p>
<p>function bootstrapDelegationHandler(element, selector, fn) {
 return function handler(event) {
   const domElements = element.querySelectorAll(selector);</p>
<p>for (let {
     target
   } = event; target &amp;&amp; target !== this; target = target.parentNode) {
     for (let i = domElements.length; i&ndash;;) {
       if (domElements[i] === target) {
         event.delegateTarget = target;</p>
<pre><code>     if (handler.oneOff) {
       EventHandler.off(element, event.type, selector, fn);
     }

     return fn.apply(target, [event]);
   }
 }
</code></pre>
<p>} // To please ESLint</p>
<p>return null;
 };
  }</p>
<p>function findHandler(events, handler, delegationSelector = null) {
 const uidEventList = Object.keys(events);</p>
<p>for (let i = 0, len = uidEventList.length; i &lt; len; i++) {
   const event = events[uidEventList[i]];</p>
<p>if (event.originalHandler === handler &amp;&amp; event.delegationSelector === delegationSelector) {
     return event;
   }
 }</p>
<p>return null;
  }</p>
<p>function normalizeParams(originalTypeEvent, handler, delegationFn) {
 const delegation = typeof handler === &lsquo;string&rsquo;;
 const originalHandler = delegation ? delegationFn : handler;
 let typeEvent = getTypeEvent(originalTypeEvent);
 const isNative = nativeEvents.has(typeEvent);</p>
<p>if (!isNative) {
   typeEvent = originalTypeEvent;
 }</p>
<p>return [delegation, originalHandler, typeEvent];
  }</p>
<p>function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
 if (typeof originalTypeEvent !== &lsquo;string&rsquo; || !element) {
   return;
 }</p>
<p>if (!handler) {
   handler = delegationFn;
   delegationFn = null;
 } // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
 // this prevents the handler from being dispatched the same way as mouseover or mouseout does</p>
<p>if (customEventsRegex.test(originalTypeEvent)) {
   const wrapFn = fn =&gt; {
     return function (event) {
       if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget &amp;&amp; !event.delegateTarget.contains(event.relatedTarget)) {
         return fn.call(this, event);
       }
     };
   };</p>
<p>if (delegationFn) {
     delegationFn = wrapFn(delegationFn);
   } else {
     handler = wrapFn(handler);
   }
 }</p>
<p>const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
 const events = getEvent(element);
 const handlers = events[typeEvent] || (events[typeEvent] = {});
 const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);</p>
<p>if (previousFn) {
   previousFn.oneOff = previousFn.oneOff &amp;&amp; oneOff;
   return;
 }</p>
<p>const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, &lsquo;&rsquo;));
 const fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);
 fn.delegationSelector = delegation ? handler : null;
 fn.originalHandler = originalHandler;
 fn.oneOff = oneOff;
 fn.uidEvent = uid;
 handlers[uid] = fn;
 element.addEventListener(typeEvent, fn, delegation);
  }</p>
<p>function removeHandler(element, events, typeEvent, handler, delegationSelector) {
 const fn = findHandler(events[typeEvent], handler, delegationSelector);</p>
<p>if (!fn) {
   return;
 }</p>
<p>element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
 delete events[typeEvent][fn.uidEvent];
  }</p>
<p>function removeNamespacedHandlers(element, events, typeEvent, namespace) {
 const storeElementEvent = events[typeEvent] || {};
 Object.keys(storeElementEvent).forEach(handlerKey =&gt; {
   if (handlerKey.includes(namespace)) {
     const event = storeElementEvent[handlerKey];
     removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
   }
 });
  }</p>
<p>function getTypeEvent(event) {
 // allow to get the native events from namespaced events (&lsquo;click.bs.button&rsquo; &ndash;&gt; &lsquo;click&rsquo;)
 event = event.replace(stripNameRegex, &lsquo;&rsquo;);
 return customEvents[event] || event;
  }</p>
<p>const EventHandler = {
 on(element, event, handler, delegationFn) {
   addHandler(element, event, handler, delegationFn, false);
 },</p>
<p>one(element, event, handler, delegationFn) {
   addHandler(element, event, handler, delegationFn, true);
 },</p>
<p>off(element, originalTypeEvent, handler, delegationFn) {
   if (typeof originalTypeEvent !== &lsquo;string&rsquo; || !element) {
     return;
   }</p>
<p>const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
   const inNamespace = typeEvent !== originalTypeEvent;
   const events = getEvent(element);
   const isNamespace = originalTypeEvent.startsWith(&lsquo;.&rsquo;);</p>
<p>if (typeof originalHandler !== &lsquo;undefined&rsquo;) {
     // Simplest case: handler is passed, remove that listener ONLY.
     if (!events || !events[typeEvent]) {
       return;
     }</p>
<pre><code> removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);
 return;
</code></pre>
<p>}</p>
<p>if (isNamespace) {
     Object.keys(events).forEach(elementEvent =&gt; {
       removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
     });
   }</p>
<p>const storeElementEvent = events[typeEvent] || {};
   Object.keys(storeElementEvent).forEach(keyHandlers =&gt; {
     const handlerKey = keyHandlers.replace(stripUidRegex, &lsquo;&rsquo;);</p>
<pre><code> if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
   const event = storeElementEvent[keyHandlers];
   removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
 }
</code></pre>
<p>});
 },</p>
<p>trigger(element, event, args) {
   if (typeof event !== &lsquo;string&rsquo; || !element) {
     return null;
   }</p>
<p>const $ = getjQuery();
   const typeEvent = getTypeEvent(event);
   const inNamespace = event !== typeEvent;
   const isNative = nativeEvents.has(typeEvent);
   let jQueryEvent;
   let bubbles = true;
   let nativeDispatch = true;
   let defaultPrevented = false;
   let evt = null;</p>
<p>if (inNamespace &amp;&amp; $) {
     jQueryEvent = $.Event(event, args);
     $(element).trigger(jQueryEvent);
     bubbles = !jQueryEvent.isPropagationStopped();
     nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
     defaultPrevented = jQueryEvent.isDefaultPrevented();
   }</p>
<p>if (isNative) {
     evt = document.createEvent(&lsquo;HTMLEvents&rsquo;);
     evt.initEvent(typeEvent, bubbles, true);
   } else {
     evt = new CustomEvent(event, {
       bubbles,
       cancelable: true
     });
   } // merge custom information in our event</p>
<p>if (typeof args !== &lsquo;undefined&rsquo;) {
     Object.keys(args).forEach(key =&gt; {
       Object.defineProperty(evt, key, {
         get() {
           return args[key];
         }</p>
<pre><code>   });
 });
</code></pre>
<p>}</p>
<p>if (defaultPrevented) {
     evt.preventDefault();
   }</p>
<p>if (nativeDispatch) {
     element.dispatchEvent(evt);
   }</p>
<p>if (evt.defaultPrevented &amp;&amp; typeof jQueryEvent !== &lsquo;undefined&rsquo;) {
     jQueryEvent.preventDefault();
   }</p>
<p>return evt;
 }</p>
<p>};</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-8'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-8'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Data</span> <span class="nx">Api</span> <span class="nx">implementation</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-9'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-9'>#</a>
      </div>
      <p>const elementMap = new Map();
  const Data = {
 set(element, key, instance) {
   if (!elementMap.has(element)) {
     elementMap.set(element, new Map());
   }</p>
<p>const instanceMap = elementMap.get(element); // make it clear we only want one instance per element
   // can be removed later when multiple key/instances are fine to be used</p>
<p>if (!instanceMap.has(key) &amp;&amp; instanceMap.size !== 0) {
     // eslint-disable-next-line no-console
     console.error(<code>Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.</code>);
     return;
   }</p>
<p>instanceMap.set(key, instance);
 },</p>
<p>get(element, key) {
   if (elementMap.has(element)) {
     return elementMap.get(element).get(key) || null;
   }</p>
<p>return null;
 },</p>
<p>remove(element, key) {
   if (!elementMap.has(element)) {
     return;
   }</p>
<p>const instanceMap = elementMap.get(element);
   instanceMap.delete(key); // free up element references if there are no instances left for an element</p>
<p>if (instanceMap.size === 0) {
     elementMap.delete(element);
   }
 }</p>
<p>};</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Button</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-10'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-10'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">dom</span><span class="o">/</span><span class="nx">manipulator</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-11'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-11'>#</a>
      </div>
      <p>const VERSION = &lsquo;5.1.3&rsquo;;</p>
<p>class BaseComponent {
 constructor(element) {
   element = getElement(element);</p>
<p>if (!element) {
     return;
   }</p>
<p>this._element = element;
   Data.set(this._element, this.constructor.DATA_KEY, this);
 }</p>
<p>dispose() {
   Data.remove(this._element, this.constructor.DATA_KEY);
   EventHandler.off(this._element, this.constructor.EVENT_KEY);
   Object.getOwnPropertyNames(this).forEach(propertyName =&gt; {
     this[propertyName] = null;
   });
 }</p>
<p>_queueCallback(callback, element, isAnimated = true) {
   executeAfterTransition(callback, element, isAnimated);
 }
* Static
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">dom</span><span class="o">/</span><span class="nx">selector</span><span class="o">-</span><span class="nx">engine</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-12'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-12'>#</a>
      </div>
      <ul>
<li>
<hr />
</li>
<li>Bootstrap (v5.1.3): util/component-functions.js</li>
<li>Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)</li>
<li>
<hr />
</li>
</ul>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">carousel</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-13'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-13'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-14'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-14'>#</a>
      </div>
      <p>const NAME$d = &lsquo;alert&rsquo;;
  const DATA_KEY$c = &lsquo;bs.alert&rsquo;;
  const EVENT_KEY$c = <code>.${DATA_KEY$c}</code>;
  const EVENT_CLOSE = <code>close${EVENT_KEY$c}</code>;
  const EVENT_CLOSED = <code>closed${EVENT_KEY$c}</code>;
  const CLASS_NAME_FADE$5 = &lsquo;fade&rsquo;;
  const CLASS_NAME_SHOW$8 = &lsquo;show&rsquo;;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-15'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-15'>#</a>
      </div>
      <p>class Alert extends BaseComponent {
 // Getters
 static get NAME() {
   return NAME$d;
 } // Public</p>
<p>close() {
   const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);</p>
<p>if (closeEvent.defaultPrevented) {
     return;
   }</p>
<p>this._element.classList.remove(CLASS_NAME_SHOW$8);</p>
<p>const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);</p>
<p>this._queueCallback(() =&gt; this._destroyElement(), this._element, isAnimated);
 } // Private</p>
<p>_destroyElement() {
   this._element.remove();</p>
<p>EventHandler.trigger(this._element, EVENT_CLOSED);
   this.dispose();
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const data = Alert.getOrCreateInstance(this);</p>
<pre><code> if (typeof config !== 'string') {
   return;
 }

 if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
   throw new TypeError(`No method named "${config}"`);
 }

 data[config](this);
</code></pre>
<p>});
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Data</span> <span class="nx">Api</span> <span class="nx">implementation</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-16'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-16'>#</a>
      </div>
      <p>enableDismissTrigger(Alert, &lsquo;close&rsquo;);
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Carousel</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-17'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-17'>#</a>
      </div>
      <p>defineJQueryPlugin(Alert);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">collapse</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-18'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-18'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-19'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-19'>#</a>
      </div>
      <p>const NAME$c = &lsquo;button&rsquo;;
  const DATA_KEY$b = &lsquo;bs.button&rsquo;;
  const EVENT_KEY$b = <code>.${DATA_KEY$b}</code>;
  const DATA_API_KEY$7 = &lsquo;.data-api&rsquo;;
  const CLASS_NAME_ACTIVE$3 = &lsquo;active&rsquo;;
  const SELECTOR_DATA_TOGGLE$5 = &lsquo;[data-bs-toggle=&rdquo;button&rdquo;]&rsquo;;
  const EVENT_CLICK_DATA_API$6 = <code>click${EVENT_KEY$b}${DATA_API_KEY$7}</code>;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-20'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-20'>#</a>
      </div>
      <p>class Button extends BaseComponent {
 // Getters
 static get NAME() {
   return NAME$c;
 } // Public</p>
<p>toggle() {
   // Toggle class and sync the <code>aria-pressed</code> attribute with the return value of the <code>.toggle()</code> method
   this._element.setAttribute(&lsquo;aria-pressed&rsquo;, this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const data = Button.getOrCreateInstance(this);</p>
<pre><code> if (config === 'toggle') {
   data[config]();
 }
</code></pre>
<p>});
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Data</span> <span class="nx">Api</span> <span class="nx">implementation</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-21'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-21'>#</a>
      </div>
      <p>EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event =&gt; {
 event.preventDefault();
 const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
 const data = Button.getOrCreateInstance(button);
 data.toggle();
  });
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Collapse</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-22'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-22'>#</a>
      </div>
      <p>defineJQueryPlugin(Button);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="nx">given</span> <span class="nx">a</span> <span class="nx">DOM</span> <span class="nx">element</span><span class="p">,</span> <span class="k">return</span> <span class="nx">the</span> <span class="nx">list</span> <span class="k">of</span> <span class="nx">all</span> <span class="nx">scroll</span> <span class="nx">parents</span><span class="p">,</span> <span class="nx">up</span> <span class="nx">the</span> <span class="nx">list</span> <span class="k">of</span> <span class="nx">ancesors</span>
  <span class="nx">until</span> <span class="nx">we</span> <span class="nx">get</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">top</span> <span class="nb">window</span> <span class="nx">object</span><span class="p">.</span> <span class="nx">This</span> <span class="nx">list</span> <span class="nx">is</span> <span class="nx">what</span> <span class="nx">we</span> <span class="nx">attach</span> <span class="nx">scroll</span> <span class="nx">listeners</span>
  <span class="nx">to</span><span class="p">,</span> <span class="nx">because</span> <span class="k">if</span> <span class="nx">any</span> <span class="k">of</span> <span class="nx">these</span> <span class="nx">parent</span> <span class="nx">elements</span> <span class="nx">scroll</span><span class="p">,</span> <span class="nx">we</span><span class="s1">&#39;ll need to re-calculate the</span>
<span class="s1">  reference element&#39;</span><span class="nx">s</span> <span class="nx">position</span><span class="p">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-23'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-23'>#</a>
      </div>
      <p>function normalizeData(val) {
 if (val === &lsquo;true&rsquo;) {
   return true;
 }</p>
<p>if (val === &lsquo;false&rsquo;) {
   return false;
 }</p>
<p>if (val === Number(val).toString()) {
   return Number(val);
 }</p>
<p>if (val === &lsquo;&rsquo; || val === &lsquo;null&rsquo;) {
   return null;
 }</p>
<p>return val;
  }</p>
<p>function normalizeDataKey(key) {
 return key.replace(/[A-Z]/g, chr =&gt; <code>-${chr.toLowerCase()}</code>);
  }</p>
<p>const Manipulator = {
 setDataAttribute(element, key, value) {
   element.setAttribute(<code>data-bs-${normalizeDataKey(key)}</code>, value);
 },</p>
<p>removeDataAttribute(element, key) {
   element.removeAttribute(<code>data-bs-${normalizeDataKey(key)}</code>);
 },</p>
<p>getDataAttributes(element) {
   if (!element) {
     return {};
   }</p>
<p>const attributes = {};
   Object.keys(element.dataset).filter(key =&gt; key.startsWith(&lsquo;bs&rsquo;)).forEach(key =&gt; {
     let pureKey = key.replace(/^bs/, &lsquo;&rsquo;);
     pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
     attributes[pureKey] = normalizeData(element.dataset[key]);
   });
   return attributes;
 },</p>
<p>getDataAttribute(element, key) {
   return normalizeData(element.getAttribute(<code>data-bs-${normalizeDataKey(key)}</code>));
 },</p>
<p>offset(element) {
   const rect = element.getBoundingClientRect();
   return {
     top: rect.top + window.pageYOffset,
     left: rect.left + window.pageXOffset
   };
 },</p>
<p>position(element) {
   return {
     top: element.offsetTop,
     left: element.offsetLeft
   };
 }</p>
<p>};</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">dropdown</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-24'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-24'>#</a>
      </div>
      <p>const NODE_TEXT = 3;
  const SelectorEngine = {
 find(selector, element = document.documentElement) {
   return [].concat(&hellip;Element.prototype.querySelectorAll.call(element, selector));
 },</p>
<p>findOne(selector, element = document.documentElement) {
   return Element.prototype.querySelector.call(element, selector);
 },</p>
<p>children(element, selector) {
   return [].concat(&hellip;element.children).filter(child =&gt; child.matches(selector));
 },</p>
<p>parents(element, selector) {
   const parents = [];
   let ancestor = element.parentNode;</p>
<p>while (ancestor &amp;&amp; ancestor.nodeType === Node.ELEMENT_NODE &amp;&amp; ancestor.nodeType !== NODE_TEXT) {
     if (ancestor.matches(selector)) {
       parents.push(ancestor);
     }</p>
<pre><code> ancestor = ancestor.parentNode;
</code></pre>
<p>}</p>
<p>return parents;
 },</p>
<p>prev(element, selector) {
   let previous = element.previousElementSibling;</p>
<p>while (previous) {
     if (previous.matches(selector)) {
       return [previous];
     }</p>
<pre><code> previous = previous.previousElementSibling;
</code></pre>
<p>}</p>
<p>return [];
 },</p>
<p>next(element, selector) {
   let next = element.nextElementSibling;</p>
<p>while (next) {
     if (next.matches(selector)) {
       return [next];
     }</p>
<pre><code> next = next.nextElementSibling;
</code></pre>
<p>}</p>
<p>return [];
 },</p>
<p>focusableChildren(element) {
   const focusables = [&lsquo;a&rsquo;, &lsquo;button&rsquo;, &lsquo;input&rsquo;, &lsquo;textarea&rsquo;, &lsquo;select&rsquo;, &lsquo;details&rsquo;, &lsquo;[tabindex]&rsquo;, &lsquo;[contenteditable=&rdquo;true&rdquo;]&rsquo;].map(selector =&gt; <code>${selector}:not([tabindex^="-"])</code>).join(&lsquo;, &lsquo;);
   return this.find(focusables, element).filter(el =&gt; !isDisabled(el) &amp;&amp; isVisible(el));
 }</p>
<p>};</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-25'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-25'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-26'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-26'>#</a>
      </div>
      <p>const NAME$b = &lsquo;carousel&rsquo;;
  const DATA_KEY$a = &lsquo;bs.carousel&rsquo;;
  const EVENT_KEY$a = <code>.${DATA_KEY$a}</code>;
  const DATA_API_KEY$6 = &lsquo;.data-api&rsquo;;
  const ARROW_LEFT_KEY = &lsquo;ArrowLeft&rsquo;;
  const ARROW_RIGHT_KEY = &lsquo;ArrowRight&rsquo;;
  const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch</p>
<p>const SWIPE_THRESHOLD = 40;
  const Default$a = {
 interval: 5000,
 keyboard: true,
 slide: false,
 pause: &lsquo;hover&rsquo;,
 wrap: true,
 touch: true
  };
  const DefaultType$a = {
 interval: &lsquo;(number|boolean)&rsquo;,
 keyboard: &lsquo;boolean&rsquo;,
 slide: &lsquo;(boolean|string)&rsquo;,
 pause: &lsquo;(string|boolean)&rsquo;,
 wrap: &lsquo;boolean&rsquo;,
 touch: &lsquo;boolean&rsquo;
  };
  const ORDER_NEXT = &lsquo;next&rsquo;;
  const ORDER_PREV = &lsquo;prev&rsquo;;
  const DIRECTION_LEFT = &lsquo;left&rsquo;;
  const DIRECTION_RIGHT = &lsquo;right&rsquo;;
  const KEY_TO_DIRECTION = {</p>
<p>};
  const EVENT_SLIDE = <code>slide${EVENT_KEY$a}</code>;
  const EVENT_SLID = <code>slid${EVENT_KEY$a}</code>;
  const EVENT_KEYDOWN = <code>keydown${EVENT_KEY$a}</code>;
  const EVENT_MOUSEENTER = <code>mouseenter${EVENT_KEY$a}</code>;
  const EVENT_MOUSELEAVE = <code>mouseleave${EVENT_KEY$a}</code>;
  const EVENT_TOUCHSTART = <code>touchstart${EVENT_KEY$a}</code>;
  const EVENT_TOUCHMOVE = <code>touchmove${EVENT_KEY$a}</code>;
  const EVENT_TOUCHEND = <code>touchend${EVENT_KEY$a}</code>;
  const EVENT_POINTERDOWN = <code>pointerdown${EVENT_KEY$a}</code>;
  const EVENT_POINTERUP = <code>pointerup${EVENT_KEY$a}</code>;
  const EVENT_DRAG_START = <code>dragstart${EVENT_KEY$a}</code>;
  const EVENT_LOAD_DATA_API$2 = <code>load${EVENT_KEY$a}${DATA_API_KEY$6}</code>;
  const EVENT_CLICK_DATA_API$5 = <code>click${EVENT_KEY$a}${DATA_API_KEY$6}</code>;
  const CLASS_NAME_CAROUSEL = &lsquo;carousel&rsquo;;
  const CLASS_NAME_ACTIVE$2 = &lsquo;active&rsquo;;
  const CLASS_NAME_SLIDE = &lsquo;slide&rsquo;;
  const CLASS_NAME_END = &lsquo;carousel-item-end&rsquo;;
  const CLASS_NAME_START = &lsquo;carousel-item-start&rsquo;;
  const CLASS_NAME_NEXT = &lsquo;carousel-item-next&rsquo;;
  const CLASS_NAME_PREV = &lsquo;carousel-item-prev&rsquo;;
  const CLASS_NAME_POINTER_EVENT = &lsquo;pointer-event&rsquo;;
  const SELECTOR_ACTIVE$1 = &lsquo;.active&rsquo;;
  const SELECTOR_ACTIVE_ITEM = &lsquo;.active.carousel-item&rsquo;;
  const SELECTOR_ITEM = &lsquo;.carousel-item&rsquo;;
  const SELECTOR_ITEM_IMG = &lsquo;.carousel-item img&rsquo;;
  const SELECTOR_NEXT_PREV = &lsquo;.carousel-item-next, .carousel-item-prev&rsquo;;
  const SELECTOR_INDICATORS = &lsquo;.carousel-indicators&rsquo;;
  const SELECTOR_INDICATOR = &lsquo;[data-bs-target]&rsquo;;
  const SELECTOR_DATA_SLIDE = &lsquo;[data-bs-slide], [data-bs-slide-to]&rsquo;;
  const SELECTOR_DATA_RIDE = &lsquo;[data-bs-ride=&rdquo;carousel&rdquo;]&rsquo;;
  const POINTER_TYPE_TOUCH = &lsquo;touch&rsquo;;
  const POINTER_TYPE_PEN = &lsquo;pen&rsquo;;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Data</span> <span class="nx">Api</span> <span class="nx">implementation</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-27'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-27'>#</a>
      </div>
      <p>class Carousel extends BaseComponent {
 constructor(element, config) {
   super(element);
   this._items = null;
   this._interval = null;
   this._activeElement = null;
   this._isPaused = false;
   this._isSliding = false;
   this.touchTimeout = null;
   this.touchStartX = 0;
   this.touchDeltaX = 0;
   this._config = this._getConfig(config);
   this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
   this._touchSupported = &lsquo;ontouchstart&rsquo; in document.documentElement || navigator.maxTouchPoints &gt; 0;
   this._pointerEvent = Boolean(window.PointerEvent);</p>
<p>this._addEventListeners();
 } // Getters</p>
<p>static get Default() {
   return Default$a;
 }</p>
<p>static get NAME() {
   return NAME$b;
 } // Public</p>
<p>next() {
   this._slide(ORDER_NEXT);
 }</p>
<p>nextWhenVisible() {
   // Don&rsquo;t call next when the page isn&rsquo;t visible
   // or the carousel or its parent isn&rsquo;t visible
   if (!document.hidden &amp;&amp; isVisible(this._element)) {
     this.next();
   }
 }</p>
<p>prev() {
   this._slide(ORDER_PREV);
 }</p>
<p>pause(event) {
   if (!event) {
     this._isPaused = true;
   }</p>
<p>if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {
     triggerTransitionEnd(this._element);
     this.cycle(true);
   }</p>
<p>clearInterval(this._interval);
   this._interval = null;
 }</p>
<p>cycle(event) {
   if (!event) {
     this._isPaused = false;
   }</p>
<p>if (this._interval) {
     clearInterval(this._interval);
     this._interval = null;
   }</p>
<p>if (this._config &amp;&amp; this._config.interval &amp;&amp; !this._isPaused) {
     this._updateInterval();</p>
<pre><code> this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
</code></pre>
<p>}
 }</p>
<p>to(index) {
   this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);</p>
<p>const activeIndex = this._getItemIndex(this._activeElement);</p>
<p>if (index &gt; this._items.length - 1 || index &lt; 0) {
     return;
   }</p>
<p>if (this._isSliding) {
     EventHandler.one(this._element, EVENT_SLID, () =&gt; this.to(index));
     return;
   }</p>
<p>if (activeIndex === index) {
     this.pause();
     this.cycle();
     return;
   }</p>
<p>const order = index &gt; activeIndex ? ORDER_NEXT : ORDER_PREV;</p>
<p>this._slide(order, this._items[index]);
 } // Private</p>
<p>_getConfig(config) {
   config = { &hellip;Default$a,
     &hellip;Manipulator.getDataAttributes(this._element),
     &hellip;(typeof config === &lsquo;object&rsquo; ? config : {})
   };
   typeCheckConfig(NAME$b, config, DefaultType$a);
   return config;
 }</p>
<p>_handleSwipe() {
   const absDeltax = Math.abs(this.touchDeltaX);</p>
<p>if (absDeltax &lt;= SWIPE_THRESHOLD) {
     return;
   }</p>
<p>const direction = absDeltax / this.touchDeltaX;
   this.touchDeltaX = 0;</p>
<p>if (!direction) {
     return;
   }</p>
<p>this._slide(direction &gt; 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);
 }</p>
<p>_addEventListeners() {
   if (this._config.keyboard) {
     EventHandler.on(this._element, EVENT_KEYDOWN, event =&gt; this._keydown(event));
   }</p>
<p>if (this._config.pause === &lsquo;hover&rsquo;) {
     EventHandler.on(this._element, EVENT_MOUSEENTER, event =&gt; this.pause(event));
     EventHandler.on(this._element, EVENT_MOUSELEAVE, event =&gt; this.cycle(event));
   }</p>
<p>if (this._config.touch &amp;&amp; this._touchSupported) {
     this._addTouchEventListeners();
   }
 }</p>
<p>_addTouchEventListeners() {
   const hasPointerPenTouch = event =&gt; {
     return this._pointerEvent &amp;&amp; (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
   };</p>
<p>const start = event =&gt; {
     if (hasPointerPenTouch(event)) {
       this.touchStartX = event.clientX;
     } else if (!this._pointerEvent) {
       this.touchStartX = event.touches[0].clientX;
     }
   };</p>
<p>const move = event =&gt; {
     // ensure swiping with one touch and not pinching
     this.touchDeltaX = event.touches &amp;&amp; event.touches.length &gt; 1 ? 0 : event.touches[0].clientX - this.touchStartX;
   };</p>
<p>const end = event =&gt; {
     if (hasPointerPenTouch(event)) {
       this.touchDeltaX = event.clientX - this.touchStartX;
     }</p>
<pre><code> this._handleSwipe();

 if (this._config.pause === 'hover') {
   // If it's a touch-enabled device, mouseenter/leave are fired as
   // part of the mouse compatibility events on first tap - the carousel
   // would stop cycling until user tapped out of it;
   // here, we listen for touchend, explicitly pause the carousel
   // (as if it's the second time we tap on it, mouseenter compat event
   // is NOT fired) and after a timeout (to allow for mouse compatibility
   // events to fire) we explicitly restart cycling
   this.pause();

   if (this.touchTimeout) {
     clearTimeout(this.touchTimeout);
   }

   this.touchTimeout = setTimeout(event =&gt; this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
 }
</code></pre>
<p>};</p>
<p>SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg =&gt; {
     EventHandler.on(itemImg, EVENT_DRAG_START, event =&gt; event.preventDefault());
   });</p>
<p>if (this._pointerEvent) {
     EventHandler.on(this._element, EVENT_POINTERDOWN, event =&gt; start(event));
     EventHandler.on(this._element, EVENT_POINTERUP, event =&gt; end(event));</p>
<pre><code> this._element.classList.add(CLASS_NAME_POINTER_EVENT);
</code></pre>
<p>} else {
     EventHandler.on(this._element, EVENT_TOUCHSTART, event =&gt; start(event));
     EventHandler.on(this._element, EVENT_TOUCHMOVE, event =&gt; move(event));
     EventHandler.on(this._element, EVENT_TOUCHEND, event =&gt; end(event));
   }
 }</p>
<p>_keydown(event) {
   if (/input|textarea/i.test(event.target.tagName)) {
     return;
   }</p>
<p>const direction = KEY_TO_DIRECTION[event.key];</p>
<p>if (direction) {
     event.preventDefault();</p>
<pre><code> this._slide(direction);
</code></pre>
<p>}
 }</p>
<p>_getItemIndex(element) {
   this._items = element &amp;&amp; element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];
   return this._items.indexOf(element);
 }</p>
<p>_getItemByOrder(order, activeElement) {
   const isNext = order === ORDER_NEXT;
   return getNextActiveElement(this._items, activeElement, isNext, this._config.wrap);
 }</p>
<p>_triggerSlideEvent(relatedTarget, eventDirectionName) {
   const targetIndex = this._getItemIndex(relatedTarget);</p>
<p>const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));</p>
<p>return EventHandler.trigger(this._element, EVENT_SLIDE, {
     relatedTarget,
     direction: eventDirectionName,
     from: fromIndex,
     to: targetIndex
   });
 }</p>
<p>_setActiveIndicatorElement(element) {
   if (this._indicatorsElement) {
     const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);
     activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
     activeIndicator.removeAttribute(&lsquo;aria-current&rsquo;);
     const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);</p>
<pre><code> for (let i = 0; i &lt; indicators.length; i++) {
   if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {
     indicators[i].classList.add(CLASS_NAME_ACTIVE$2);
     indicators[i].setAttribute('aria-current', 'true');
     break;
   }
 }
</code></pre>
<p>}
 }</p>
<p>_updateInterval() {
   const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);</p>
<p>if (!element) {
     return;
   }</p>
<p>const elementInterval = Number.parseInt(element.getAttribute(&lsquo;data-bs-interval&rsquo;), 10);</p>
<p>if (elementInterval) {
     this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
     this._config.interval = elementInterval;
   } else {
     this._config.interval = this._config.defaultInterval || this._config.interval;
   }
 }</p>
<p>_slide(directionOrOrder, element) {
   const order = this._directionToOrder(directionOrOrder);</p>
<p>const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);</p>
<p>const activeElementIndex = this._getItemIndex(activeElement);</p>
<p>const nextElement = element || this._getItemByOrder(order, activeElement);</p>
<p>const nextElementIndex = this._getItemIndex(nextElement);</p>
<p>const isCycling = Boolean(this._interval);
   const isNext = order === ORDER_NEXT;
   const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
   const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;</p>
<p>const eventDirectionName = this._orderToDirection(order);</p>
<p>if (nextElement &amp;&amp; nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {
     this._isSliding = false;
     return;
   }</p>
<p>if (this._isSliding) {
     return;
   }</p>
<p>const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);</p>
<p>if (slideEvent.defaultPrevented) {
     return;
   }</p>
<p>if (!activeElement || !nextElement) {
     // Some weirdness is happening, so we bail
     return;
   }</p>
<p>this._isSliding = true;</p>
<p>if (isCycling) {
     this.pause();
   }</p>
<p>this._setActiveIndicatorElement(nextElement);</p>
<p>this._activeElement = nextElement;</p>
<p>const triggerSlidEvent = () =&gt; {
     EventHandler.trigger(this._element, EVENT_SLID, {
       relatedTarget: nextElement,
       direction: eventDirectionName,
       from: activeElementIndex,
       to: nextElementIndex
     });
   };</p>
<p>if (this._element.classList.contains(CLASS_NAME_SLIDE)) {
     nextElement.classList.add(orderClassName);
     reflow(nextElement);
     activeElement.classList.add(directionalClassName);
     nextElement.classList.add(directionalClassName);</p>
<pre><code> const completeCallBack = () =&gt; {
   nextElement.classList.remove(directionalClassName, orderClassName);
   nextElement.classList.add(CLASS_NAME_ACTIVE$2);
   activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
   this._isSliding = false;
   setTimeout(triggerSlidEvent, 0);
 };

 this._queueCallback(completeCallBack, activeElement, true);
</code></pre>
<p>} else {
     activeElement.classList.remove(CLASS_NAME_ACTIVE$2);
     nextElement.classList.add(CLASS_NAME_ACTIVE$2);
     this._isSliding = false;
     triggerSlidEvent();
   }</p>
<p>if (isCycling) {
     this.cycle();
   }
 }</p>
<p>_directionToOrder(direction) {
   if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {
     return direction;
   }</p>
<p>if (isRTL()) {
     return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
   }</p>
<p>return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
 }</p>
<p>_orderToDirection(order) {
   if (![ORDER_NEXT, ORDER_PREV].includes(order)) {
     return order;
   }</p>
<p>if (isRTL()) {
     return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
   }</p>
<p>return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
 } // Static</p>
<p>static carouselInterface(element, config) {
   const data = Carousel.getOrCreateInstance(element, config);
   let {
     _config
   } = data;</p>
<p>if (typeof config === &lsquo;object&rsquo;) {
     _config = { &hellip;_config,
       &hellip;config
     };
   }</p>
<p>const action = typeof config === &lsquo;string&rsquo; ? config : _config.slide;</p>
<p>if (typeof config === &lsquo;number&rsquo;) {
     data.to(config);
   } else if (typeof action === &lsquo;string&rsquo;) {
     if (typeof data[action] === &lsquo;undefined&rsquo;) {
       throw new TypeError(<code>No method named "${action}"</code>);
     }</p>
<pre><code> data[action]();
</code></pre>
<p>} else if (_config.interval &amp;&amp; _config.ride) {
     data.pause();
     data.cycle();
   }
 }</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     Carousel.carouselInterface(this, config);
   });
 }</p>
<p>static dataApiClickHandler(event) {
   const target = getElementFromSelector(this);</p>
<p>if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
     return;
   }</p>
<p>const config = { &hellip;Manipulator.getDataAttributes(target),
     &hellip;Manipulator.getDataAttributes(this)
   };
   const slideIndex = this.getAttribute(&lsquo;data-bs-slide-to&rsquo;);</p>
<p>if (slideIndex) {
     config.interval = false;
   }</p>
<p>Carousel.carouselInterface(target, config);</p>
<p>if (slideIndex) {
     Carousel.getInstance(target).to(slideIndex);
   }</p>
<p>event.preventDefault();
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Dropdown</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-28'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-28'>#</a>
      </div>
      <p>EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () =&gt; {
 const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);</p>
<p>for (let i = 0, len = carousels.length; i &lt; len; i++) {
   Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]));
 }
  });
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">util</span><span class="o">/</span><span class="nx">scrollBar</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-29'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-29'>#</a>
      </div>
      <p>defineJQueryPlugin(Carousel);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">util</span><span class="o">/</span><span class="nx">backdrop</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-30'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-30'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">util</span><span class="o">/</span><span class="nx">focustrap</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-31'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-31'>#</a>
      </div>
      <p>const NAME$a = &lsquo;collapse&rsquo;;
  const DATA_KEY$9 = &lsquo;bs.collapse&rsquo;;
  const EVENT_KEY$9 = <code>.${DATA_KEY$9}</code>;
  const DATA_API_KEY$5 = &lsquo;.data-api&rsquo;;
  const Default$9 = {
 toggle: true,
 parent: null
  };
  const DefaultType$9 = {
 toggle: &lsquo;boolean&rsquo;,
 parent: &lsquo;(null|element)&rsquo;
  };
  const EVENT_SHOW$5 = <code>show${EVENT_KEY$9}</code>;
  const EVENT_SHOWN$5 = <code>shown${EVENT_KEY$9}</code>;
  const EVENT_HIDE$5 = <code>hide${EVENT_KEY$9}</code>;
  const EVENT_HIDDEN$5 = <code>hidden${EVENT_KEY$9}</code>;
  const EVENT_CLICK_DATA_API$4 = <code>click${EVENT_KEY$9}${DATA_API_KEY$5}</code>;
  const CLASS_NAME_SHOW$7 = &lsquo;show&rsquo;;
  const CLASS_NAME_COLLAPSE = &lsquo;collapse&rsquo;;
  const CLASS_NAME_COLLAPSING = &lsquo;collapsing&rsquo;;
  const CLASS_NAME_COLLAPSED = &lsquo;collapsed&rsquo;;
  const CLASS_NAME_DEEPER_CHILDREN = <code>:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}</code>;
  const CLASS_NAME_HORIZONTAL = &lsquo;collapse-horizontal&rsquo;;
  const WIDTH = &lsquo;width&rsquo;;
  const HEIGHT = &lsquo;height&rsquo;;
  const SELECTOR_ACTIVES = &lsquo;.collapse.show, .collapse.collapsing&rsquo;;
  const SELECTOR_DATA_TOGGLE$4 = &lsquo;[data-bs-toggle=&rdquo;collapse&rdquo;]&rsquo;;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">modal</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-32'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-32'>#</a>
      </div>
      <p>class Collapse extends BaseComponent {
 constructor(element, config) {
   super(element);
   this._isTransitioning = false;
   this._config = this._getConfig(config);
   this._triggerArray = [];
   const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);</p>
<p>for (let i = 0, len = toggleList.length; i &lt; len; i++) {
     const elem = toggleList[i];
     const selector = getSelectorFromElement(elem);
     const filterElement = SelectorEngine.find(selector).filter(foundElem =&gt; foundElem === this._element);</p>
<pre><code> if (selector !== null &amp;&amp; filterElement.length) {
   this._selector = selector;

   this._triggerArray.push(elem);
 }
</code></pre>
<p>}</p>
<p>this._initializeChildren();</p>
<p>if (!this._config.parent) {
     this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
   }</p>
<p>if (this._config.toggle) {
     this.toggle();
   }
 } // Getters</p>
<p>static get Default() {
   return Default$9;
 }</p>
<p>static get NAME() {
   return NAME$a;
 } // Public</p>
<p>toggle() {
   if (this._isShown()) {
     this.hide();
   } else {
     this.show();
   }
 }</p>
<p>show() {
   if (this._isTransitioning || this._isShown()) {
     return;
   }</p>
<p>let actives = [];
   let activesData;</p>
<p>if (this._config.parent) {
     const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
     actives = SelectorEngine.find(SELECTOR_ACTIVES, this._config.parent).filter(elem =&gt; !children.includes(elem)); // remove children if greater depth
   }</p>
<p>const container = SelectorEngine.findOne(this._selector);</p>
<p>if (actives.length) {
     const tempActiveData = actives.find(elem =&gt; container !== elem);
     activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;</p>
<pre><code> if (activesData &amp;&amp; activesData._isTransitioning) {
   return;
 }
</code></pre>
<p>}</p>
<p>const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);</p>
<p>if (startEvent.defaultPrevented) {
     return;
   }</p>
<p>actives.forEach(elemActive =&gt; {
     if (container !== elemActive) {
       Collapse.getOrCreateInstance(elemActive, {
         toggle: false
       }).hide();
     }</p>
<pre><code> if (!activesData) {
   Data.set(elemActive, DATA_KEY$9, null);
 }
</code></pre>
<p>});</p>
<p>const dimension = this._getDimension();</p>
<p>this._element.classList.remove(CLASS_NAME_COLLAPSE);</p>
<p>this._element.classList.add(CLASS_NAME_COLLAPSING);</p>
<p>this._element.style[dimension] = 0;</p>
<p>this._addAriaAndCollapsedClass(this._triggerArray, true);</p>
<p>this._isTransitioning = true;</p>
<p>const complete = () =&gt; {
     this._isTransitioning = false;</p>
<pre><code> this._element.classList.remove(CLASS_NAME_COLLAPSING);

 this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);

 this._element.style[dimension] = '';
 EventHandler.trigger(this._element, EVENT_SHOWN$5);
</code></pre>
<p>};</p>
<p>const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
   const scrollSize = <code>scroll${capitalizedDimension}</code>;</p>
<p>this._queueCallback(complete, this._element, true);</p>
<p>this._element.style[dimension] = <code>${this._element[scrollSize]}px</code>;
 }</p>
<p>hide() {
   if (this._isTransitioning || !this._isShown()) {
     return;
   }</p>
<p>const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);</p>
<p>if (startEvent.defaultPrevented) {
     return;
   }</p>
<p>const dimension = this._getDimension();</p>
<p>this._element.style[dimension] = <code>${this._element.getBoundingClientRect()[dimension]}px</code>;
   reflow(this._element);</p>
<p>this._element.classList.add(CLASS_NAME_COLLAPSING);</p>
<p>this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);</p>
<p>const triggerArrayLength = this._triggerArray.length;</p>
<p>for (let i = 0; i &lt; triggerArrayLength; i++) {
     const trigger = this._triggerArray[i];
     const elem = getElementFromSelector(trigger);</p>
<pre><code> if (elem &amp;&amp; !this._isShown(elem)) {
   this._addAriaAndCollapsedClass([trigger], false);
 }
</code></pre>
<p>}</p>
<p>this._isTransitioning = true;</p>
<p>const complete = () =&gt; {
     this._isTransitioning = false;</p>
<pre><code> this._element.classList.remove(CLASS_NAME_COLLAPSING);

 this._element.classList.add(CLASS_NAME_COLLAPSE);

 EventHandler.trigger(this._element, EVENT_HIDDEN$5);
</code></pre>
<p>};</p>
<p>this._element.style[dimension] = &lsquo;&rsquo;;</p>
<p>this._queueCallback(complete, this._element, true);
 }</p>
<p>_isShown(element = this._element) {
   return element.classList.contains(CLASS_NAME_SHOW$7);
 } // Private</p>
<p>_getConfig(config) {
   config = { &hellip;Default$9,
     &hellip;Manipulator.getDataAttributes(this._element),
     &hellip;config
   };
   config.toggle = Boolean(config.toggle); // Coerce string values</p>
<p>config.parent = getElement(config.parent);
   typeCheckConfig(NAME$a, config, DefaultType$9);
   return config;
 }</p>
<p>_getDimension() {
   return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
 }</p>
<p>_initializeChildren() {
   if (!this._config.parent) {
     return;
   }</p>
<p>const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
   SelectorEngine.find(SELECTOR_DATA_TOGGLE$4, this._config.parent).filter(elem =&gt; !children.includes(elem)).forEach(element =&gt; {
     const selected = getElementFromSelector(element);</p>
<pre><code> if (selected) {
   this._addAriaAndCollapsedClass([element], this._isShown(selected));
 }
</code></pre>
<p>});
 }</p>
<p>_addAriaAndCollapsedClass(triggerArray, isOpen) {
   if (!triggerArray.length) {
     return;
   }</p>
<p>triggerArray.forEach(elem =&gt; {
     if (isOpen) {
       elem.classList.remove(CLASS_NAME_COLLAPSED);
     } else {
       elem.classList.add(CLASS_NAME_COLLAPSED);
     }</p>
<pre><code> elem.setAttribute('aria-expanded', isOpen);
</code></pre>
<p>});
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const _config = {};</p>
<pre><code> if (typeof config === 'string' &amp;&amp; /show|hide/.test(config)) {
   _config.toggle = false;
 }

 const data = Collapse.getOrCreateInstance(this, _config);

 if (typeof config === 'string') {
   if (typeof data[config] === 'undefined') {
     throw new TypeError(`No method named "${config}"`);
   }

   data[config]();
 }
</code></pre>
<p>});
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-33'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-33'>#</a>
      </div>
      <p>EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
 // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
 if (event.target.tagName === &lsquo;A&rsquo; || event.delegateTarget &amp;&amp; event.delegateTarget.tagName === &lsquo;A&rsquo;) {
   event.preventDefault();
 }</p>
<p>const selector = getSelectorFromElement(this);
 const selectorElements = SelectorEngine.find(selector);
 selectorElements.forEach(element =&gt; {
   Collapse.getOrCreateInstance(element, {
     toggle: false
   }).toggle();
 });
  });
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-34'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-34'>#</a>
      </div>
      <p>defineJQueryPlugin(Collapse);</p>
<p>var top = &lsquo;top&rsquo;;
  var bottom = &lsquo;bottom&rsquo;;
  var right = &lsquo;right&rsquo;;
  var left = &lsquo;left&rsquo;;
  var auto = &lsquo;auto&rsquo;;
  var basePlacements = [top, bottom, right, left];
  var start = &lsquo;start&rsquo;;
  var end = &lsquo;end&rsquo;;
  var clippingParents = &lsquo;clippingParents&rsquo;;
  var viewport = &lsquo;viewport&rsquo;;
  var popper = &lsquo;popper&rsquo;;
  var reference = &lsquo;reference&rsquo;;
  var variationPlacements = /<em>#<strong>PURE</strong></em>/basePlacements.reduce(function (acc, placement) {
 return acc.concat([placement + &ldquo;-&rdquo; + start, placement + &ldquo;-&rdquo; + end]);
  }, []);
  var placements = /<em>#<strong>PURE</strong></em>/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
 return acc.concat([placement, placement + &ldquo;-&rdquo; + start, placement + &ldquo;-&rdquo; + end]);
  }, []); // modifiers that need to read the DOM</p>
<p>var beforeRead = &lsquo;beforeRead&rsquo;;
  var read = &lsquo;read&rsquo;;
  var afterRead = &lsquo;afterRead&rsquo;; // pure-logic modifiers</p>
<p>var beforeMain = &lsquo;beforeMain&rsquo;;
  var main = &lsquo;main&rsquo;;
  var afterMain = &lsquo;afterMain&rsquo;; // modifier with the purpose to write to the DOM (or write into a framework state)</p>
<p>var beforeWrite = &lsquo;beforeWrite&rsquo;;
  var write = &lsquo;write&rsquo;;
  var afterWrite = &lsquo;afterWrite&rsquo;;
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];</p>
<p>function getNodeName(element) {
 return element ? (element.nodeName || &lsquo;&rsquo;).toLowerCase() : null;
  }</p>
<p>function getWindow(node) {
 if (node == null) {
   return window;
 }</p>
<p>if (node.toString() !== &lsquo;[object Window]&rsquo;) {
   var ownerDocument = node.ownerDocument;
   return ownerDocument ? ownerDocument.defaultView || window : window;
 }</p>
<p>return node;
  }</p>
<p>function isElement(node) {
 var OwnElement = getWindow(node).Element;
 return node instanceof OwnElement || node instanceof Element;
  }</p>
<p>function isHTMLElement(node) {
 var OwnElement = getWindow(node).HTMLElement;
 return node instanceof OwnElement || node instanceof HTMLElement;
  }</p>
<p>function isShadowRoot(node) {
 // IE 11 has no ShadowRoot
 if (typeof ShadowRoot === &lsquo;undefined&rsquo;) {
   return false;
 }</p>
<p>var OwnElement = getWindow(node).ShadowRoot;
 return node instanceof OwnElement || node instanceof ShadowRoot;
  }</p>
<p>// and applies them to the HTMLElements such as popper and arrow</p>
<p>function applyStyles(_ref) {
 var state = _ref.state;
 Object.keys(state.elements).forEach(function (name) {
   var style = state.styles[name] || {};
   var attributes = state.attributes[name] || {};
   var element = state.elements[name]; // arrow is optional + virtual elements</p>
<p>if (!isHTMLElement(element) || !getNodeName(element)) {
     return;
   } // Flow doesn&rsquo;t support to extend this property, but it&rsquo;s the most
   // effective way to apply styles to an HTMLElement
   // $FlowFixMe[cannot-write]</p>
<p>Object.assign(element.style, style);
   Object.keys(attributes).forEach(function (name) {
     var value = attributes[name];</p>
<pre><code> if (value === false) {
   element.removeAttribute(name);
 } else {
   element.setAttribute(name, value === true ? '' : value);
 }
</code></pre>
<p>});
 });
  }</p>
<p>function effect$2(_ref2) {
 var state = _ref2.state;
 var initialStyles = {
   popper: {
     position: state.options.strategy,
     left: &lsquo;0&rsquo;,
     top: &lsquo;0&rsquo;,
     margin: &lsquo;0&rsquo;
   },
   arrow: {
     position: &lsquo;absolute&rsquo;
   },
   reference: {}
 };
 Object.assign(state.elements.popper.style, initialStyles.popper);
 state.styles = initialStyles;</p>
<p>if (state.elements.arrow) {
   Object.assign(state.elements.arrow.style, initialStyles.arrow);
 }</p>
<p>return function () {
   Object.keys(state.elements).forEach(function (name) {
     var element = state.elements[name];
     var attributes = state.attributes[name] || {};
     var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them</p>
<pre><code> var style = styleProperties.reduce(function (style, property) {
   style[property] = '';
   return style;
 }, {}); // arrow is optional + virtual elements

 if (!isHTMLElement(element) || !getNodeName(element)) {
   return;
 }

 Object.assign(element.style, style);
 Object.keys(attributes).forEach(function (attribute) {
   element.removeAttribute(attribute);
 });
</code></pre>
<p>});
 };
  } // eslint-disable-next-line import/no-unused-modules</p>
<p>const applyStyles$1 = {
 name: &lsquo;applyStyles&rsquo;,
 enabled: true,
 phase: &lsquo;write&rsquo;,
 fn: applyStyles,
 effect: effect$2,
 requires: [&lsquo;computeStyles&rsquo;]
  };</p>
<p>function getBasePlacement(placement) {
 return placement.split(&lsquo;-&lsquo;)[0];
  }</p>
<p>// import { isHTMLElement } from &lsquo;./instanceOf&rsquo;;
  function getBoundingClientRect(element, // eslint-disable-next-line unused-imports/no-unused-vars
  includeScale) {</p>
<p>var rect = element.getBoundingClientRect();
 var scaleX = 1;
 var scaleY = 1; // FIXME:
 // <code>offsetWidth</code> returns an integer while <code>getBoundingClientRect</code>
 // returns a float. This results in <code>scaleX</code> or <code>scaleY</code> being
 // non-1 when it should be for elements that aren&rsquo;t a full pixel in
 // width or height.
 // if (isHTMLElement(element) &amp;&amp; includeScale) {
 //   const offsetHeight = element.offsetHeight;
 //   const offsetWidth = element.offsetWidth;
 //   // Do not attempt to divide by 0, otherwise we get <code>Infinity</code> as scale
 //   // Fallback to 1 in case both values are <code>0</code>
 //   if (offsetWidth &gt; 0) {
 //     scaleX = rect.width / offsetWidth || 1;
 //   }
 //   if (offsetHeight &gt; 0) {
 //     scaleY = rect.height / offsetHeight || 1;
 //   }
 // }</p>
<p>return {
   width: rect.width / scaleX,
   height: rect.height / scaleY,
   top: rect.top / scaleY,
   right: rect.right / scaleX,
   bottom: rect.bottom / scaleY,
   left: rect.left / scaleX,
   x: rect.left / scaleX,
   y: rect.top / scaleY
 };
  }</p>
<p>// means it doesn&rsquo;t take into account transforms.</p>
<p>function getLayoutRect(element) {
 var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it&rsquo;s not been transformed.
 // Fixes https://github.com/popperjs/popper-core/issues/1223</p>
<p>var width = element.offsetWidth;
 var height = element.offsetHeight;</p>
<p>if (Math.abs(clientRect.width - width) &lt;= 1) {
   width = clientRect.width;
 }</p>
<p>if (Math.abs(clientRect.height - height) &lt;= 1) {
   height = clientRect.height;
 }</p>
<p>return {
   x: element.offsetLeft,
   y: element.offsetTop,
   width: width,
   height: height
 };
  }</p>
<p>function contains(parent, child) {
 var rootNode = child.getRootNode &amp;&amp; child.getRootNode(); // First, attempt with faster native method</p>
<p>if (parent.contains(child)) {
   return true;
 } // then fallback to custom implementation with Shadow DOM support
 else if (rootNode &amp;&amp; isShadowRoot(rootNode)) {
     var next = child;</p>
<pre><code> do {
   if (next &amp;&amp; parent.isSameNode(next)) {
     return true;
   } // $FlowFixMe[prop-missing]: need a better way to handle this...


   next = next.parentNode || next.host;
 } while (next);
</code></pre>
<p>} // Give up, the result is false</p>
<p>return false;
  }</p>
<p>function getComputedStyle$1(element) {
 return getWindow(element).getComputedStyle(element);
  }</p>
<p>function isTableElement(element) {
 return [&lsquo;table&rsquo;, &lsquo;td&rsquo;, &lsquo;th&rsquo;].indexOf(getNodeName(element)) &gt;= 0;
  }</p>
<p>function getDocumentElement(element) {
 // $FlowFixMe[incompatible-return]: assume body is always available
 return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
 element.document) || window.document).documentElement;
  }</p>
<p>function getParentNode(element) {
 if (getNodeName(element) === &lsquo;html&rsquo;) {
   return element;
 }</p>
<p>return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
   // $FlowFixMe[incompatible-return]
   // $FlowFixMe[prop-missing]
   element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
   element.parentNode || ( // DOM Element detected
   isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
   // $FlowFixMe[incompatible-call]: HTMLElement is a Node
   getDocumentElement(element) // fallback</p>
<p>);
  }</p>
<p>function getTrueOffsetParent(element) {
 if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
 getComputedStyle$1(element).position === &lsquo;fixed&rsquo;) {
   return null;
 }</p>
<p>return element.offsetParent;
  } // <code>.offsetParent</code> reports <code>null</code> for fixed elements, while absolute elements
  // return the containing block</p>
<p>function getContainingBlock(element) {
 var isFirefox = navigator.userAgent.toLowerCase().indexOf(&lsquo;firefox&rsquo;) !== -1;
 var isIE = navigator.userAgent.indexOf(&lsquo;Trident&rsquo;) !== -1;</p>
<p>if (isIE &amp;&amp; isHTMLElement(element)) {
   // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
   var elementCss = getComputedStyle$1(element);</p>
<p>if (elementCss.position === &lsquo;fixed&rsquo;) {
     return null;
   }
 }</p>
<p>var currentNode = getParentNode(element);</p>
<p>while (isHTMLElement(currentNode) &amp;&amp; [&lsquo;html&rsquo;, &lsquo;body&rsquo;].indexOf(getNodeName(currentNode)) &lt; 0) {
   var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
   // create a containing block.
   // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block</p>
<p>if (css.transform !== &lsquo;none&rsquo; || css.perspective !== &lsquo;none&rsquo; || css.contain === &lsquo;paint&rsquo; || [&lsquo;transform&rsquo;, &lsquo;perspective&rsquo;].indexOf(css.willChange) !== -1 || isFirefox &amp;&amp; css.willChange === &lsquo;filter&rsquo; || isFirefox &amp;&amp; css.filter &amp;&amp; css.filter !== &lsquo;none&rsquo;) {
     return currentNode;
   } else {
     currentNode = currentNode.parentNode;
   }
 }</p>
<p>return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.</p>
<p>function getOffsetParent(element) {
 var window = getWindow(element);
 var offsetParent = getTrueOffsetParent(element);</p>
<p>while (offsetParent &amp;&amp; isTableElement(offsetParent) &amp;&amp; getComputedStyle$1(offsetParent).position === &lsquo;static&rsquo;) {
   offsetParent = getTrueOffsetParent(offsetParent);
 }</p>
<p>if (offsetParent &amp;&amp; (getNodeName(offsetParent) === &lsquo;html&rsquo; || getNodeName(offsetParent) === &lsquo;body&rsquo; &amp;&amp; getComputedStyle$1(offsetParent).position === &lsquo;static&rsquo;)) {
   return window;
 }</p>
<p>return offsetParent || getContainingBlock(element) || window;
  }</p>
<p>function getMainAxisFromPlacement(placement) {
 return [&lsquo;top&rsquo;, &lsquo;bottom&rsquo;].indexOf(placement) &gt;= 0 ? &lsquo;x&rsquo; : &lsquo;y&rsquo;;
  }</p>
<p>var max = Math.max;
  var min = Math.min;
  var round = Math.round;</p>
<p>function within(min$1, value, max$1) {
 return max(min$1, min(value, max$1));
  }</p>
<p>function getFreshSideObject() {
 return {
   top: 0,
   right: 0,
   bottom: 0,
   left: 0
 };
  }</p>
<p>function mergePaddingObject(paddingObject) {
 return Object.assign({}, getFreshSideObject(), paddingObject);
  }</p>
<p>function expandToHashMap(value, keys) {
 return keys.reduce(function (hashMap, key) {
   hashMap[key] = value;
   return hashMap;
 }, {});
  }</p>
<p>var toPaddingObject = function toPaddingObject(padding, state) {
 padding = typeof padding === &lsquo;function&rsquo; ? padding(Object.assign({}, state.rects, {
   placement: state.placement
 })) : padding;
 return mergePaddingObject(typeof padding !== &lsquo;number&rsquo; ? padding : expandToHashMap(padding, basePlacements));
  };</p>
<p>function arrow(_ref) {
 var _state$modifiersData$;</p>
<p>var state = _ref.state,
     name = _ref.name,
     options = _ref.options;
 var arrowElement = state.elements.arrow;
 var popperOffsets = state.modifiersData.popperOffsets;
 var basePlacement = getBasePlacement(state.placement);
 var axis = getMainAxisFromPlacement(basePlacement);
 var isVertical = [left, right].indexOf(basePlacement) &gt;= 0;
 var len = isVertical ? &lsquo;height&rsquo; : &lsquo;width&rsquo;;</p>
<p>if (!arrowElement || !popperOffsets) {
   return;
 }</p>
<p>var paddingObject = toPaddingObject(options.padding, state);
 var arrowRect = getLayoutRect(arrowElement);
 var minProp = axis === &lsquo;y&rsquo; ? top : left;
 var maxProp = axis === &lsquo;y&rsquo; ? bottom : right;
 var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
 var startDiff = popperOffsets[axis] - state.rects.reference[axis];
 var arrowOffsetParent = getOffsetParent(arrowElement);
 var clientSize = arrowOffsetParent ? axis === &lsquo;y&rsquo; ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
 var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn&rsquo;t overflow the popper if the center point is
 // outside of the popper bounds</p>
<p>var min = paddingObject[minProp];
 var max = clientSize - arrowRect[len] - paddingObject[maxProp];
 var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
 var offset = within(min, center, max); // Prevents breaking syntax highlighting&hellip;</p>
<p>var axisProp = axis;
 state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }</p>
<p>function effect$1(_ref2) {
 var state = _ref2.state,
     options = _ref2.options;
 var _options$element = options.element,
     arrowElement = _options$element === void 0 ? &lsquo;[data-popper-arrow]&rsquo; : _options$element;</p>
<p>if (arrowElement == null) {
   return;
 } // CSS selector</p>
<p>if (typeof arrowElement === &lsquo;string&rsquo;) {
   arrowElement = state.elements.popper.querySelector(arrowElement);</p>
<p>if (!arrowElement) {
     return;
   }
 }</p>
<p>if (!contains(state.elements.popper, arrowElement)) {</p>
<p>return;
 }</p>
<p>state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules</p>
<p>const arrow$1 = {
 name: &lsquo;arrow&rsquo;,
 enabled: true,
 phase: &lsquo;main&rsquo;,
 fn: arrow,
 effect: effect$1,
 requires: [&lsquo;popperOffsets&rsquo;],
 requiresIfExists: [&lsquo;preventOverflow&rsquo;]
  };</p>
<p>function getVariation(placement) {
 return placement.split(&lsquo;-&lsquo;)[1];
  }</p>
<p>var unsetSides = {
 top: &lsquo;auto&rsquo;,
 right: &lsquo;auto&rsquo;,
 bottom: &lsquo;auto&rsquo;,
 left: &lsquo;auto&rsquo;
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.</p>
<p>function roundOffsetsByDPR(_ref) {
 var x = _ref.x,
     y = _ref.y;
 var win = window;
 var dpr = win.devicePixelRatio || 1;
 return {
   x: round(round(x * dpr) / dpr) || 0,
   y: round(round(y * dpr) / dpr) || 0
 };
  }</p>
<p>function mapToStyles(_ref2) {
 var _Object$assign2;</p>
<p>var popper = _ref2.popper,
     popperRect = _ref2.popperRect,
     placement = _ref2.placement,
     variation = _ref2.variation,
     offsets = _ref2.offsets,
     position = _ref2.position,
     gpuAcceleration = _ref2.gpuAcceleration,
     adaptive = _ref2.adaptive,
     roundOffsets = _ref2.roundOffsets;</p>
<p>var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === &lsquo;function&rsquo; ? roundOffsets(offsets) : offsets,
     _ref3$x = _ref3.x,
     x = _ref3$x === void 0 ? 0 : _ref3$x,
     _ref3$y = _ref3.y,
     y = _ref3$y === void 0 ? 0 : _ref3$y;</p>
<p>var hasX = offsets.hasOwnProperty(&lsquo;x&rsquo;);
 var hasY = offsets.hasOwnProperty(&lsquo;y&rsquo;);
 var sideX = left;
 var sideY = top;
 var win = window;</p>
<p>if (adaptive) {
   var offsetParent = getOffsetParent(popper);
   var heightProp = &lsquo;clientHeight&rsquo;;
   var widthProp = &lsquo;clientWidth&rsquo;;</p>
<p>if (offsetParent === getWindow(popper)) {
     offsetParent = getDocumentElement(popper);</p>
<pre><code> if (getComputedStyle$1(offsetParent).position !== 'static' &amp;&amp; position === 'absolute') {
   heightProp = 'scrollHeight';
   widthProp = 'scrollWidth';
 }
</code></pre>
<p>} // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn&rsquo;t detect it</p>
<p>offsetParent = offsetParent;</p>
<p>if (placement === top || (placement === left || placement === right) &amp;&amp; variation === end) {
     sideY = bottom; // $FlowFixMe[prop-missing]</p>
<pre><code> y -= offsetParent[heightProp] - popperRect.height;
 y *= gpuAcceleration ? 1 : -1;
</code></pre>
<p>}</p>
<p>if (placement === left || (placement === top || placement === bottom) &amp;&amp; variation === end) {
     sideX = right; // $FlowFixMe[prop-missing]</p>
<pre><code> x -= offsetParent[widthProp] - popperRect.width;
 x *= gpuAcceleration ? 1 : -1;
</code></pre>
<p>}
 }</p>
<p>var commonStyles = Object.assign({
   position: position
 }, adaptive &amp;&amp; unsetSides);</p>
<p>if (gpuAcceleration) {
   var _Object$assign;</p>
<p>return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? &lsquo;0&rsquo; : &lsquo;&rsquo;, _Object$assign[sideX] = hasX ? &lsquo;0&rsquo; : &lsquo;&rsquo;, _Object$assign.transform = (win.devicePixelRatio || 1) &lt;= 1 ? &ldquo;translate(&rdquo; + x + &ldquo;px, &rdquo; + y + &ldquo;px)&rdquo; : &ldquo;translate3d(&rdquo; + x + &ldquo;px, &rdquo; + y + &ldquo;px, 0)&rdquo;, _Object$assign));
 }</p>
<p>return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + &ldquo;px&rdquo; : &lsquo;&rsquo;, _Object$assign2[sideX] = hasX ? x + &ldquo;px&rdquo; : &lsquo;&rsquo;, _Object$assign2.transform = &lsquo;&rsquo;, _Object$assign2));
  }</p>
<p>function computeStyles(_ref4) {
 var state = _ref4.state,
     options = _ref4.options;
 var _options$gpuAccelerat = options.gpuAcceleration,
     gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
     _options$adaptive = options.adaptive,
     adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
     _options$roundOffsets = options.roundOffsets,
     roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;</p>
<p>var commonStyles = {
   placement: getBasePlacement(state.placement),
   variation: getVariation(state.placement),
   popper: state.elements.popper,
   popperRect: state.rects.popper,
   gpuAcceleration: gpuAcceleration
 };</p>
<p>if (state.modifiersData.popperOffsets != null) {
   state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
     offsets: state.modifiersData.popperOffsets,
     position: state.options.strategy,
     adaptive: adaptive,
     roundOffsets: roundOffsets
   })));
 }</p>
<p>if (state.modifiersData.arrow != null) {
   state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
     offsets: state.modifiersData.arrow,
     position: &lsquo;absolute&rsquo;,
     adaptive: false,
     roundOffsets: roundOffsets
   })));
 }</p>
<p>state.attributes.popper = Object.assign({}, state.attributes.popper, {
   &lsquo;data-popper-placement&rsquo;: state.placement
 });
  } // eslint-disable-next-line import/no-unused-modules</p>
<p>const computeStyles$1 = {
 name: &lsquo;computeStyles&rsquo;,
 enabled: true,
 phase: &lsquo;beforeWrite&rsquo;,
 fn: computeStyles,
 data: {}
  };</p>
<p>var passive = {
 passive: true
  };</p>
<p>function effect(_ref) {
 var state = _ref.state,
     instance = _ref.instance,
     options = _ref.options;
 var _options$scroll = options.scroll,
     scroll = _options$scroll === void 0 ? true : _options$scroll,
     _options$resize = options.resize,
     resize = _options$resize === void 0 ? true : _options$resize;
 var window = getWindow(state.elements.popper);
 var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);</p>
<p>if (scroll) {
   scrollParents.forEach(function (scrollParent) {
     scrollParent.addEventListener(&lsquo;scroll&rsquo;, instance.update, passive);
   });
 }</p>
<p>if (resize) {
   window.addEventListener(&lsquo;resize&rsquo;, instance.update, passive);
 }</p>
<p>return function () {
   if (scroll) {
     scrollParents.forEach(function (scrollParent) {
       scrollParent.removeEventListener(&lsquo;scroll&rsquo;, instance.update, passive);
     });
   }</p>
<p>if (resize) {
     window.removeEventListener(&lsquo;resize&rsquo;, instance.update, passive);
   }
 };
  } // eslint-disable-next-line import/no-unused-modules</p>
<p>const eventListeners = {
 name: &lsquo;eventListeners&rsquo;,
 enabled: true,
 phase: &lsquo;write&rsquo;,
 fn: function fn() {},
 effect: effect,
 data: {}
  };</p>
<p>var hash$1 = {
 left: &lsquo;right&rsquo;,
 right: &lsquo;left&rsquo;,
 bottom: &lsquo;top&rsquo;,
 top: &lsquo;bottom&rsquo;
  };
  function getOppositePlacement(placement) {
 return placement.replace(/left|right|bottom|top/g, function (matched) {
   return hash$1[matched];
 });
  }</p>
<p>var hash = {
 start: &lsquo;end&rsquo;,
 end: &lsquo;start&rsquo;
  };
  function getOppositeVariationPlacement(placement) {
 return placement.replace(/start|end/g, function (matched) {
   return hash[matched];
 });
  }</p>
<p>function getWindowScroll(node) {
 var win = getWindow(node);
 var scrollLeft = win.pageXOffset;
 var scrollTop = win.pageYOffset;
 return {
   scrollLeft: scrollLeft,
   scrollTop: scrollTop
 };
  }</p>
<p>function getWindowScrollBarX(element) {
 // If <html> has a CSS width greater than the viewport, then this will be
 // incorrect for RTL.
 // Popper 1 is broken in this case and never had a bug report so let&rsquo;s assume
 // it&rsquo;s not an issue. I don&rsquo;t think anyone ever specifies width on <html>
 // anyway.
 // Browsers where the left scrollbar doesn&rsquo;t cause an issue report <code>0</code> for
 // this (e.g. Edge 2019, IE11, Safari)
 return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }</p>
<p>function getViewportRect(element) {
 var win = getWindow(element);
 var html = getDocumentElement(element);
 var visualViewport = win.visualViewport;
 var width = html.clientWidth;
 var height = html.clientHeight;
 var x = 0;
 var y = 0; // NB: This isn&rsquo;t supported on iOS &lt;= 12. If the keyboard is open, the popper
 // can be obscured underneath it.
 // Also, <code>html.clientHeight</code> adds the bottom bar height in Safari iOS, even
 // if it isn&rsquo;t open, so if this isn&rsquo;t available, the popper will be detected
 // to overflow the bottom of the screen too early.</p>
<p>if (visualViewport) {
   width = visualViewport.width;
   height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
   // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
   // errors due to floating point numbers, so we need to check precision.
   // Safari returns a number &lt;= 0, usually &lt; -1 when pinch-zoomed
   // Feature detection fails in mobile emulation mode in Chrome.
   // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) &lt;
   // 0.001
   // Fallback here: &ldquo;Not Safari&rdquo; userAgent</p>
<p>if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
     x = visualViewport.offsetLeft;
     y = visualViewport.offsetTop;
   }
 }</p>
<p>return {
   width: width,
   height: height,
   x: x + getWindowScrollBarX(element),
   y: y
 };
  }</p>
<p>// of the <code>&lt;html&gt;</code> and <code>&lt;body&gt;</code> rect bounds if horizontally scrollable</p>
<p>function getDocumentRect(element) {
 var _element$ownerDocumen;</p>
<p>var html = getDocumentElement(element);
 var winScroll = getWindowScroll(element);
 var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
 var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
 var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
 var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
 var y = -winScroll.scrollTop;</p>
<p>if (getComputedStyle$1(body || html).direction === &lsquo;rtl&rsquo;) {
   x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
 }</p>
<p>return {
   width: width,
   height: height,
   x: x,
   y: y
 };
  }</p>
<p>function isScrollParent(element) {
 // Firefox wants us to check <code>-x</code> and <code>-y</code> variations as well
 var _getComputedStyle = getComputedStyle$1(element),
     overflow = _getComputedStyle.overflow,
     overflowX = _getComputedStyle.overflowX,
     overflowY = _getComputedStyle.overflowY;</p>
<p>return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }</p>
<p>function getScrollParent(node) {
 if ([&lsquo;html&rsquo;, &lsquo;body&rsquo;, &lsquo;#document&rsquo;].indexOf(getNodeName(node)) &gt;= 0) {
   // $FlowFixMe[incompatible-return]: assume body is always available
   return node.ownerDocument.body;
 }</p>
<p>if (isHTMLElement(node) &amp;&amp; isScrollParent(node)) {
   return node;
 }</p>
<p>return getScrollParent(getParentNode(node));
  }</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Data</span> <span class="nx">Api</span> <span class="nx">implementation</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-35'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-35'>#</a>
      </div>
      <p>function listScrollParents(element, list) {
  var _element$ownerDocumen;</p>
<p>if (list === void 0) {
    list = [];
  }</p>
<p>var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}</p>
<p>function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}</p>
<p>function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}</p>
<p>function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A &ldquo;clipping parent&rdquo; is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// <code>initial</code></p>
<p>function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = [&lsquo;absolute&rsquo;, &lsquo;fixed&rsquo;].indexOf(getComputedStyle$1(element).position) &gt;= 0;
  var clipperElement = canEscapeClipping &amp;&amp; isHTMLElement(element) ? getOffsetParent(element) : element;</p>
<p>if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414</p>
<p>return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) &amp;&amp; contains(clippingParent, clipperElement) &amp;&amp; getNodeName(clippingParent) !== &lsquo;body&rsquo;;
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents</p>
<p>function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === &lsquo;clippingParents&rsquo; ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}</p>
<p>function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;</p>
<p>switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;</p>
<pre><code>case bottom:
  offsets = {
    x: commonX,
    y: reference.y + reference.height
  };
  break;

case right:
  offsets = {
    x: reference.x + reference.width,
    y: commonY
  };
  break;

case left:
  offsets = {
    x: reference.x - element.width,
    y: commonY
  };
  break;

default:
  offsets = {
    x: reference.x,
    y: reference.y
  };
</code></pre>
<p>}</p>
<p>var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;</p>
<p>if (mainAxis != null) {
    var len = mainAxis === &lsquo;y&rsquo; ? &lsquo;height&rsquo; : &lsquo;width&rsquo;;</p>
<pre><code>switch (variation) {
  case start:
    offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
    break;

  case end:
    offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
    break;
}
</code></pre>
<p>}</p>
<p>return offsets;
}</p>
<p>function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }</p>
<p>var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== &lsquo;number&rsquo; ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: &lsquo;absolute&rsquo;,
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect</p>
<p>var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element</p>
<p>if (elementContext === popper &amp;&amp; offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) &gt;= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) &gt;= 0 ? &lsquo;y&rsquo; : &lsquo;x&rsquo;;
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }</p>
<p>return overflowOffsets;
}</p>
<p>function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }</p>
<p>var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) &gt;= 0;
  });</p>
<p>if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions&hellip;</p>
<p>var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}</p>
<p>function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }</p>
<p>var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}</p>
<p>function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;</p>
<p>if (state.modifiersData[name]._skip) {
    return;
  }</p>
<p>var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];</p>
<p>for (var i = 0; i &lt; placements.length; i++) {
    var placement = placements[i];</p>
<pre><code>var _basePlacement = getBasePlacement(placement);

var isStartVariation = getVariation(placement) === start;
var isVertical = [top, bottom].indexOf(_basePlacement) &gt;= 0;
var len = isVertical ? 'width' : 'height';
var overflow = detectOverflow(state, {
  placement: placement,
  boundary: boundary,
  rootBoundary: rootBoundary,
  altBoundary: altBoundary,
  padding: padding
});
var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

if (referenceRect[len] &gt; popperRect[len]) {
  mainVariationSide = getOppositePlacement(mainVariationSide);
}

var altVariationSide = getOppositePlacement(mainVariationSide);
var checks = [];

if (checkMainAxis) {
  checks.push(overflow[_basePlacement] &lt;= 0);
}

if (checkAltAxis) {
  checks.push(overflow[mainVariationSide] &lt;= 0, overflow[altVariationSide] &lt;= 0);
}

if (checks.every(function (check) {
  return check;
})) {
  firstFittingPlacement = placement;
  makeFallbackChecks = false;
  break;
}

checksMap.set(placement, checks);
</code></pre>
<p>}</p>
<p>if (makeFallbackChecks) {
    // <code>2</code> may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;</p>
<pre><code>var _loop = function _loop(_i) {
  var fittingPlacement = placements.find(function (placement) {
    var checks = checksMap.get(placement);

    if (checks) {
      return checks.slice(0, _i).every(function (check) {
        return check;
      });
    }
  });

  if (fittingPlacement) {
    firstFittingPlacement = fittingPlacement;
    return "break";
  }
};

for (var _i = numberOfChecks; _i &gt; 0; _i--) {
  var _ret = _loop(_i);

  if (_ret === "break") break;
}
</code></pre>
<p>}</p>
<p>if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules</p>
<p>const flip$1 = {
  name: &lsquo;flip&rsquo;,
  enabled: true,
  phase: &lsquo;main&rsquo;,
  fn: flip,
  requiresIfExists: [&lsquo;offset&rsquo;],
  data: {
    _skip: false
  }
};</p>
<p>function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }</p>
<p>return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}</p>
<p>function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] &gt;= 0;
  });
}</p>
<p>function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: &lsquo;reference&rsquo;
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    &lsquo;data-popper-reference-hidden&rsquo;: isReferenceHidden,
    &lsquo;data-popper-escaped&rsquo;: hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules</p>
<p>const hide$1 = {
  name: &lsquo;hide&rsquo;,
  enabled: true,
  phase: &lsquo;main&rsquo;,
  requiresIfExists: [&lsquo;preventOverflow&rsquo;],
  fn: hide
};</p>
<p>function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) &gt;= 0 ? -1 : 1;</p>
<p>var _ref = typeof offset === &lsquo;function&rsquo; ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];</p>
<p>skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) &gt;= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}</p>
<p>function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;</p>
<p>if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }</p>
<p>state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules</p>
<p>const offset$1 = {
  name: &lsquo;offset&rsquo;,
  enabled: true,
  phase: &lsquo;main&rsquo;,
  requires: [&lsquo;popperOffsets&rsquo;],
  fn: offset
};</p>
<p>function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: &lsquo;absolute&rsquo;,
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules</p>
<p>const popperOffsets$1 = {
  name: &lsquo;popperOffsets&rsquo;,
  enabled: true,
  phase: &lsquo;read&rsquo;,
  fn: popperOffsets,
  data: {}
};</p>
<p>function getAltAxis(axis) {
  return axis === &lsquo;x&rsquo; ? &lsquo;y&rsquo; : &lsquo;x&rsquo;;
}</p>
<p>function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === &lsquo;function&rsquo; ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };</p>
<p>if (!popperOffsets) {
    return;
  }</p>
<p>if (checkMainAxis || checkAltAxis) {
    var mainSide = mainAxis === &lsquo;y&rsquo; ? top : left;
    var altSide = mainAxis === &lsquo;y&rsquo; ? bottom : right;
    var len = mainAxis === &lsquo;y&rsquo; ? &lsquo;height&rsquo; : &lsquo;width&rsquo;;
    var offset = popperOffsets[mainAxis];
    var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
    var max$1 = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn&rsquo;t go
    // outside the reference bounds</p>
<pre><code>var arrowElement = state.elements.arrow;
var arrowRect = tether &amp;&amp; arrowElement ? getLayoutRect(arrowElement) : {
  width: 0,
  height: 0
};
var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
var arrowPaddingMin = arrowPaddingObject[mainSide];
var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
// to include its full size in the calculation. If the reference is small
// and near the edge of a boundary, the popper can overflow even if the
// reference is not overflowing as well (e.g. virtual elements with no
// width or height)

var arrowLen = within(0, referenceRect[len], arrowRect[len]);
var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
var arrowOffsetParent = state.elements.arrow &amp;&amp; getOffsetParent(state.elements.arrow);
var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

if (checkMainAxis) {
  var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
  popperOffsets[mainAxis] = preventedOffset;
  data[mainAxis] = preventedOffset - offset;
}

if (checkAltAxis) {
  var _mainSide = mainAxis === 'x' ? top : left;

  var _altSide = mainAxis === 'x' ? bottom : right;

  var _offset = popperOffsets[altAxis];

  var _min = _offset + overflow[_mainSide];

  var _max = _offset - overflow[_altSide];

  var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

  popperOffsets[altAxis] = _preventedOffset;
  data[altAxis] = _preventedOffset - _offset;
}
</code></pre>
<p>}</p>
<p>state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules</p>
<p>const preventOverflow$1 = {
  name: &lsquo;preventOverflow&rsquo;,
  enabled: true,
  phase: &lsquo;main&rsquo;,
  fn: preventOverflow,
  requiresIfExists: [&lsquo;offset&rsquo;]
};</p>
<p>function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}</p>
<p>function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}</p>
<p>function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = rect.width / element.offsetWidth || 1;
  var scaleY = rect.height / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.</p>
<p>function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }</p>
<p>var isOffsetParentAnElement = isHTMLElement(offsetParent);
  isHTMLElement(offsetParent) &amp;&amp; isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };</p>
<p>if (isOffsetParentAnElement || !isOffsetParentAnElement &amp;&amp; !isFixed) {
    if (getNodeName(offsetParent) !== &lsquo;body&rsquo; || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }</p>
<pre><code>if (isHTMLElement(offsetParent)) {
  offsets = getBoundingClientRect(offsetParent);
  offsets.x += offsetParent.clientLeft;
  offsets.y += offsetParent.clientTop;
} else if (documentElement) {
  offsets.x = getWindowScrollBarX(documentElement);
}
</code></pre>
<p>}</p>
<p>return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}</p>
<p>function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively</p>
<p>function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);</p>
<pre><code>    if (depModifier) {
      sort(depModifier);
    }
  }
});
result.push(modifier);
</code></pre>
<p>}</p>
<p>modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}</p>
<p>function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase</p>
<p>return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}</p>
<p>function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }</p>
<pre><code>return pending;
</code></pre>
<p>};
}</p>
<p>function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values</p>
<p>return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}</p>
<p>var DEFAULT_OPTIONS = {
  placement: &lsquo;bottom&rsquo;,
  modifiers: [],
  strategy: &lsquo;absolute&rsquo;
};</p>
<p>function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key &lt; _len; _key++) {
    args[_key] = arguments[_key];
  }</p>
<p>return !args.some(function (element) {
    return !(element &amp;&amp; typeof element.getBoundingClientRect === &lsquo;function&rsquo;);
  });
}</p>
<p>function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }</p>
<p>var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }</p>
<pre><code>var state = {
  placement: 'bottom',
  orderedModifiers: [],
  options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
  modifiersData: {},
  elements: {
    reference: reference,
    popper: popper
  },
  attributes: {},
  styles: {}
};
var effectCleanupFns = [];
var isDestroyed = false;
var instance = {
  state: state,
  setOptions: function setOptions(setOptionsAction) {
    var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
    cleanupModifierEffects();
    state.options = Object.assign({}, defaultOptions, state.options, options);
    state.scrollParents = {
      reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
      popper: listScrollParents(popper)
    }; // Orders the modifiers based on their dependencies and `phase`
    // properties

    var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

    state.orderedModifiers = orderedModifiers.filter(function (m) {
      return m.enabled;
    }); // Validate the provided modifiers so that the consumer will get warned

    runModifierEffects();
    return instance.update();
  },
  // Sync update  it will always be executed, even if not necessary. This
  // is useful for low frequency updates where sync behavior simplifies the
  // logic.
  // For high frequency updates (e.g. `resize` and `scroll` events), always
  // prefer the async Popper#update method
  forceUpdate: function forceUpdate() {
    if (isDestroyed) {
      return;
    }

    var _state$elements = state.elements,
        reference = _state$elements.reference,
        popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
    // anymore

    if (!areValidElements(reference, popper)) {

      return;
    } // Store the reference and popper rects to be read by modifiers


    state.rects = {
      reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
      popper: getLayoutRect(popper)
    }; // Modifiers have the ability to reset the current update cycle. The
    // most common use case for this is the `flip` modifier changing the
    // placement, which then needs to re-run all the modifiers, because the
    // logic was previously ran for the previous placement and is therefore
    // stale/incorrect

    state.reset = false;
    state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
    // is filled with the initial data specified by the modifier. This means
    // it doesn't persist and is fresh on each update.
    // To ensure persistent data, use `${name}#persistent`

    state.orderedModifiers.forEach(function (modifier) {
      return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
    });

    for (var index = 0; index &lt; state.orderedModifiers.length; index++) {

      if (state.reset === true) {
        state.reset = false;
        index = -1;
        continue;
      }

      var _state$orderedModifie = state.orderedModifiers[index],
          fn = _state$orderedModifie.fn,
          _state$orderedModifie2 = _state$orderedModifie.options,
          _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
          name = _state$orderedModifie.name;

      if (typeof fn === 'function') {
        state = fn({
          state: state,
          options: _options,
          name: name,
          instance: instance
        }) || state;
      }
    }
  },
  // Async and optimistically optimized update  it will not be executed if
  // not necessary (debounced to run at most once-per-tick)
  update: debounce(function () {
    return new Promise(function (resolve) {
      instance.forceUpdate();
      resolve(state);
    });
  }),
  destroy: function destroy() {
    cleanupModifierEffects();
    isDestroyed = true;
  }
};

if (!areValidElements(reference, popper)) {

  return instance;
}

instance.setOptions(options).then(function (state) {
  if (!isDestroyed &amp;&amp; options.onFirstUpdate) {
    options.onFirstUpdate(state);
  }
}); // Modifiers have the ability to execute arbitrary code before the first
// update cycle runs. They will be executed in the same order as the update
// cycle. This is useful when a modifier adds some persistent data that
// other modifiers need to use, but the modifier is run after the dependent
// one.

function runModifierEffects() {
  state.orderedModifiers.forEach(function (_ref3) {
    var name = _ref3.name,
        _ref3$options = _ref3.options,
        options = _ref3$options === void 0 ? {} : _ref3$options,
        effect = _ref3.effect;

    if (typeof effect === 'function') {
      var cleanupFn = effect({
        state: state,
        name: name,
        instance: instance,
        options: options
      });

      var noopFn = function noopFn() {};

      effectCleanupFns.push(cleanupFn || noopFn);
    }
  });
}

function cleanupModifierEffects() {
  effectCleanupFns.forEach(function (fn) {
    return fn();
  });
  effectCleanupFns = [];
}

return instance;
</code></pre>
<p>};
}
var createPopper$2 = /<em>#<strong>PURE</strong></em>/popperGenerator(); // eslint-disable-next-line import/no-unused-modules</p>
<p>var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /<em>#<strong>PURE</strong></em>/popperGenerator({
  defaultModifiers: defaultModifiers$1
}); // eslint-disable-next-line import/no-unused-modules</p>
<p>var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /<em>#<strong>PURE</strong></em>/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules</p>
<p>const Popper = /<em>#<strong>PURE</strong></em>/Object.freeze({
  <strong>proto</strong>: null,
  popperGenerator,
  detectOverflow,
  createPopperBase: createPopper$2,
  createPopper,
  createPopperLite: createPopper$1,
  top,
  bottom,
  right,
  left,
  auto,
  basePlacements,
  start,
  end,
  clippingParents,
  viewport,
  popper,
  reference,
  variationPlacements,
  placements,
  beforeRead,
  read,
  afterRead,
  beforeMain,
  main,
  afterMain,
  beforeWrite,
  write,
  afterWrite,
  modifierPhases,
  applyStyles: applyStyles$1,
  arrow: arrow$1,
  computeStyles: computeStyles$1,
  eventListeners,
  flip: flip$1,
  hide: hide$1,
  offset: offset$1,
  popperOffsets: popperOffsets$1,
  preventOverflow: preventOverflow$1
});</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Modal</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-36'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-36'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">offcanvas</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-37'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-37'>#</a>
      </div>
      <p>const NAME$9 = &lsquo;dropdown&rsquo;;
  const DATA_KEY$8 = &lsquo;bs.dropdown&rsquo;;
  const EVENT_KEY$8 = <code>.${DATA_KEY$8}</code>;
  const DATA_API_KEY$4 = &lsquo;.data-api&rsquo;;
  const ESCAPE_KEY$2 = &lsquo;Escape&rsquo;;
  const SPACE_KEY = &lsquo;Space&rsquo;;
  const TAB_KEY$1 = &lsquo;Tab&rsquo;;
  const ARROW_UP_KEY = &lsquo;ArrowUp&rsquo;;
  const ARROW_DOWN_KEY = &lsquo;ArrowDown&rsquo;;
  const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button</p>
<p>const REGEXP_KEYDOWN = new RegExp(<code>${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}</code>);
  const EVENT_HIDE$4 = <code>hide${EVENT_KEY$8}</code>;
  const EVENT_HIDDEN$4 = <code>hidden${EVENT_KEY$8}</code>;
  const EVENT_SHOW$4 = <code>show${EVENT_KEY$8}</code>;
  const EVENT_SHOWN$4 = <code>shown${EVENT_KEY$8}</code>;
  const EVENT_CLICK_DATA_API$3 = <code>click${EVENT_KEY$8}${DATA_API_KEY$4}</code>;
  const EVENT_KEYDOWN_DATA_API = <code>keydown${EVENT_KEY$8}${DATA_API_KEY$4}</code>;
  const EVENT_KEYUP_DATA_API = <code>keyup${EVENT_KEY$8}${DATA_API_KEY$4}</code>;
  const CLASS_NAME_SHOW$6 = &lsquo;show&rsquo;;
  const CLASS_NAME_DROPUP = &lsquo;dropup&rsquo;;
  const CLASS_NAME_DROPEND = &lsquo;dropend&rsquo;;
  const CLASS_NAME_DROPSTART = &lsquo;dropstart&rsquo;;
  const CLASS_NAME_NAVBAR = &lsquo;navbar&rsquo;;
  const SELECTOR_DATA_TOGGLE$3 = &lsquo;[data-bs-toggle=&rdquo;dropdown&rdquo;]&rsquo;;
  const SELECTOR_MENU = &lsquo;.dropdown-menu&rsquo;;
  const SELECTOR_NAVBAR_NAV = &lsquo;.navbar-nav&rsquo;;
  const SELECTOR_VISIBLE_ITEMS = &lsquo;.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)&rsquo;;
  const PLACEMENT_TOP = isRTL() ? &lsquo;top-end&rsquo; : &lsquo;top-start&rsquo;;
  const PLACEMENT_TOPEND = isRTL() ? &lsquo;top-start&rsquo; : &lsquo;top-end&rsquo;;
  const PLACEMENT_BOTTOM = isRTL() ? &lsquo;bottom-end&rsquo; : &lsquo;bottom-start&rsquo;;
  const PLACEMENT_BOTTOMEND = isRTL() ? &lsquo;bottom-start&rsquo; : &lsquo;bottom-end&rsquo;;
  const PLACEMENT_RIGHT = isRTL() ? &lsquo;left-start&rsquo; : &lsquo;right-start&rsquo;;
  const PLACEMENT_LEFT = isRTL() ? &lsquo;right-start&rsquo; : &lsquo;left-start&rsquo;;
  const Default$8 = {
 offset: [0, 2],
 boundary: &lsquo;clippingParents&rsquo;,
 reference: &lsquo;toggle&rsquo;,
 display: &lsquo;dynamic&rsquo;,
 popperConfig: null,
 autoClose: true
  };
  const DefaultType$8 = {
 offset: &lsquo;(array|string|function)&rsquo;,
 boundary: &lsquo;(string|element)&rsquo;,
 reference: &lsquo;(string|element|object)&rsquo;,
 display: &lsquo;string&rsquo;,
 popperConfig: &lsquo;(null|object|function)&rsquo;,
 autoClose: &lsquo;(boolean|string)&rsquo;
  };
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-38'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-38'>#</a>
      </div>
      <p>class Dropdown extends BaseComponent {
 constructor(element, config) {
   super(element);
   this._popper = null;
   this._config = this._getConfig(config);
   this._menu = this._getMenuElement();
   this._inNavbar = this._detectNavbar();
 } // Getters</p>
<p>static get Default() {
   return Default$8;
 }</p>
<p>static get DefaultType() {
   return DefaultType$8;
 }</p>
<p>static get NAME() {
   return NAME$9;
 } // Public</p>
<p>toggle() {
   return this._isShown() ? this.hide() : this.show();
 }</p>
<p>show() {
   if (isDisabled(this._element) || this._isShown(this._menu)) {
     return;
   }</p>
<p>const relatedTarget = {
     relatedTarget: this._element
   };
   const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);</p>
<p>if (showEvent.defaultPrevented) {
     return;
   }</p>
<p>const parent = Dropdown.getParentFromElement(this._element); // Totally disable Popper for Dropdowns in Navbar</p>
<p>if (this._inNavbar) {
     Manipulator.setDataAttribute(this._menu, &lsquo;popper&rsquo;, &lsquo;none&rsquo;);
   } else {
     this._createPopper(parent);
   } // If this is a touch-enabled device we add extra
   // empty mouseover listeners to the body&rsquo;s immediate children;
   // only needed because of broken event delegation on iOS
   // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html</p>
<p>if (&lsquo;ontouchstart&rsquo; in document.documentElement &amp;&amp; !parent.closest(SELECTOR_NAVBAR_NAV)) {
     [].concat(&hellip;document.body.children).forEach(elem =&gt; EventHandler.on(elem, &lsquo;mouseover&rsquo;, noop));
   }</p>
<p>this._element.focus();</p>
<p>this._element.setAttribute(&lsquo;aria-expanded&rsquo;, true);</p>
<p>this._menu.classList.add(CLASS_NAME_SHOW$6);</p>
<p>this._element.classList.add(CLASS_NAME_SHOW$6);</p>
<p>EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);
 }</p>
<p>hide() {
   if (isDisabled(this._element) || !this._isShown(this._menu)) {
     return;
   }</p>
<p>const relatedTarget = {
     relatedTarget: this._element
   };</p>
<p>this._completeHide(relatedTarget);
 }</p>
<p>dispose() {
   if (this._popper) {
     this._popper.destroy();
   }</p>
<p>super.dispose();
 }</p>
<p>update() {
   this._inNavbar = this._detectNavbar();</p>
<p>if (this._popper) {
     this._popper.update();
   }
 } // Private</p>
<p>_completeHide(relatedTarget) {
   const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);</p>
<p>if (hideEvent.defaultPrevented) {
     return;
   } // If this is a touch-enabled device we remove the extra
   // empty mouseover listeners we added for iOS support</p>
<p>if (&lsquo;ontouchstart&rsquo; in document.documentElement) {
     [].concat(&hellip;document.body.children).forEach(elem =&gt; EventHandler.off(elem, &lsquo;mouseover&rsquo;, noop));
   }</p>
<p>if (this._popper) {
     this._popper.destroy();
   }</p>
<p>this._menu.classList.remove(CLASS_NAME_SHOW$6);</p>
<p>this._element.classList.remove(CLASS_NAME_SHOW$6);</p>
<p>this._element.setAttribute(&lsquo;aria-expanded&rsquo;, &lsquo;false&rsquo;);</p>
<p>Manipulator.removeDataAttribute(this._menu, &lsquo;popper&rsquo;);
   EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);
 }</p>
<p>_getConfig(config) {
   config = { &hellip;this.constructor.Default,
     &hellip;Manipulator.getDataAttributes(this._element),
     &hellip;config
   };
   typeCheckConfig(NAME$9, config, this.constructor.DefaultType);</p>
<p>if (typeof config.reference === &lsquo;object&rsquo; &amp;&amp; !isElement$1(config.reference) &amp;&amp; typeof config.reference.getBoundingClientRect !== &lsquo;function&rsquo;) {
     // Popper virtual elements require a getBoundingClientRect method
     throw new TypeError(<code>${NAME$9.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.</code>);
   }</p>
<p>return config;
 }</p>
<p>_createPopper(parent) {
   if (typeof Popper === &lsquo;undefined&rsquo;) {
     throw new TypeError(&lsquo;Bootstrap's dropdowns require Popper (https://popper.js.org)&rsquo;);
   }</p>
<p>let referenceElement = this._element;</p>
<p>if (this._config.reference === &lsquo;parent&rsquo;) {
     referenceElement = parent;
   } else if (isElement$1(this._config.reference)) {
     referenceElement = getElement(this._config.reference);
   } else if (typeof this._config.reference === &lsquo;object&rsquo;) {
     referenceElement = this._config.reference;
   }</p>
<p>const popperConfig = this._getPopperConfig();</p>
<p>const isDisplayStatic = popperConfig.modifiers.find(modifier =&gt; modifier.name === &lsquo;applyStyles&rsquo; &amp;&amp; modifier.enabled === false);
   this._popper = createPopper(referenceElement, this._menu, popperConfig);</p>
<p>if (isDisplayStatic) {
     Manipulator.setDataAttribute(this._menu, &lsquo;popper&rsquo;, &lsquo;static&rsquo;);
   }
 }</p>
<p>_isShown(element = this._element) {
   return element.classList.contains(CLASS_NAME_SHOW$6);
 }</p>
<p>_getMenuElement() {
   return SelectorEngine.next(this._element, SELECTOR_MENU)[0];
 }</p>
<p>_getPlacement() {
   const parentDropdown = this._element.parentNode;</p>
<p>if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
     return PLACEMENT_RIGHT;
   }</p>
<p>if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
     return PLACEMENT_LEFT;
   } // We need to trim the value because custom properties can also include spaces</p>
<p>const isEnd = getComputedStyle(this._menu).getPropertyValue(&lsquo;&ndash;bs-position&rsquo;).trim() === &lsquo;end&rsquo;;</p>
<p>if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
     return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
   }</p>
<p>return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
 }</p>
<p>_detectNavbar() {
   return this._element.closest(<code>.${CLASS_NAME_NAVBAR}</code>) !== null;
 }</p>
<p>_getOffset() {
   const {
     offset
   } = this._config;</p>
<p>if (typeof offset === &lsquo;string&rsquo;) {
     return offset.split(&lsquo;,&rsquo;).map(val =&gt; Number.parseInt(val, 10));
   }</p>
<p>if (typeof offset === &lsquo;function&rsquo;) {
     return popperData =&gt; offset(popperData, this._element);
   }</p>
<p>return offset;
 }</p>
<p>_getPopperConfig() {
   const defaultBsPopperConfig = {
     placement: this._getPlacement(),
     modifiers: [{
       name: &lsquo;preventOverflow&rsquo;,
       options: {
         boundary: this._config.boundary
       }
     }, {
       name: &lsquo;offset&rsquo;,
       options: {
         offset: this._getOffset()
       }
     }]
   }; // Disable Popper if we have a static display</p>
<p>if (this._config.display === &lsquo;static&rsquo;) {
     defaultBsPopperConfig.modifiers = [{
       name: &lsquo;applyStyles&rsquo;,
       enabled: false
     }];
   }</p>
<p>return { &hellip;defaultBsPopperConfig,
     &hellip;(typeof this._config.popperConfig === &lsquo;function&rsquo; ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)
   };
 }</p>
<p>_selectMenuItem({
   key,
   target
 }) {
   const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);</p>
<p>if (!items.length) {
     return;
   } // if target isn&rsquo;t included in items (e.g. when expanding the dropdown)
   // allow cycling to get the last item in case key equals ARROW_UP_KEY</p>
<p>getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const data = Dropdown.getOrCreateInstance(this, config);</p>
<pre><code> if (typeof config !== 'string') {
   return;
 }

 if (typeof data[config] === 'undefined') {
   throw new TypeError(`No method named "${config}"`);
 }

 data[config]();
</code></pre>
<p>});
 }</p>
<p>static clearMenus(event) {
   if (event &amp;&amp; (event.button === RIGHT_MOUSE_BUTTON || event.type === &lsquo;keyup&rsquo; &amp;&amp; event.key !== TAB_KEY$1)) {
     return;
   }</p>
<p>const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);</p>
<p>for (let i = 0, len = toggles.length; i &lt; len; i++) {
     const context = Dropdown.getInstance(toggles[i]);</p>
<pre><code> if (!context || context._config.autoClose === false) {
   continue;
 }

 if (!context._isShown()) {
   continue;
 }

 const relatedTarget = {
   relatedTarget: context._element
 };

 if (event) {
   const composedPath = event.composedPath();
   const isMenuTarget = composedPath.includes(context._menu);

   if (composedPath.includes(context._element) || context._config.autoClose === 'inside' &amp;&amp; !isMenuTarget || context._config.autoClose === 'outside' &amp;&amp; isMenuTarget) {
     continue;
   } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu


   if (context._menu.contains(event.target) &amp;&amp; (event.type === 'keyup' &amp;&amp; event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
     continue;
   }

   if (event.type === 'click') {
     relatedTarget.clickEvent = event;
   }
 }

 context._completeHide(relatedTarget);
</code></pre>
<p>}
 }</p>
<p>static getParentFromElement(element) {
   return getElementFromSelector(element) || element.parentNode;
 }</p>
<p>static dataApiKeydownHandler(event) {
   // If not input/textarea:
   //  - And not a key in REGEXP_KEYDOWN =&gt; not a dropdown command
   // If input/textarea:
   //  - If space key =&gt; not a dropdown command
   //  - If key is other than escape
   //    - If key is not up or down =&gt; not a dropdown command
   //    - If trigger inside the menu =&gt; not a dropdown command
   if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 &amp;&amp; (event.key !== ARROW_DOWN_KEY &amp;&amp; event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {
     return;
   }</p>
<p>const isActive = this.classList.contains(CLASS_NAME_SHOW$6);</p>
<p>if (!isActive &amp;&amp; event.key === ESCAPE_KEY$2) {
     return;
   }</p>
<p>event.preventDefault();
   event.stopPropagation();</p>
<p>if (isDisabled(this)) {
     return;
   }</p>
<p>const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];
   const instance = Dropdown.getOrCreateInstance(getToggleButton);</p>
<p>if (event.key === ESCAPE_KEY$2) {
     instance.hide();
     return;
   }</p>
<p>if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {
     if (!isActive) {
       instance.show();
     }</p>
<pre><code> instance._selectMenuItem(event);

 return;
</code></pre>
<p>}</p>
<p>if (!isActive || event.key === SPACE_KEY) {
     Dropdown.clearMenus();
   }
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-39'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-39'>#</a>
      </div>
      <p>EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
 event.preventDefault();
 Dropdown.getOrCreateInstance(this).toggle();
  });
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Data</span> <span class="nx">Api</span> <span class="nx">implementation</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-40'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-40'>#</a>
      </div>
      <p>defineJQueryPlugin(Dropdown);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-41'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-41'>#</a>
      </div>
      <p>const SELECTOR_FIXED_CONTENT = &lsquo;.fixed-top, .fixed-bottom, .is-fixed, .sticky-top&rsquo;;
  const SELECTOR_STICKY_CONTENT = &lsquo;.sticky-top&rsquo;;</p>
<p>class ScrollBarHelper {
 constructor() {
   this._element = document.body;
 }</p>
<p>getWidth() {
   // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
   const documentWidth = document.documentElement.clientWidth;
   return Math.abs(window.innerWidth - documentWidth);
 }</p>
<p>hide() {
   const width = this.getWidth();</p>
<p>this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width</p>
<p>this._setElementAttributes(this._element, &lsquo;paddingRight&rsquo;, calculatedValue =&gt; calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth</p>
<p>this._setElementAttributes(SELECTOR_FIXED_CONTENT, &lsquo;paddingRight&rsquo;, calculatedValue =&gt; calculatedValue + width);</p>
<p>this._setElementAttributes(SELECTOR_STICKY_CONTENT, &lsquo;marginRight&rsquo;, calculatedValue =&gt; calculatedValue - width);
 }</p>
<p>_disableOverFlow() {
   this._saveInitialAttribute(this._element, &lsquo;overflow&rsquo;);</p>
<p>this._element.style.overflow = &lsquo;hidden&rsquo;;
 }</p>
<p>_setElementAttributes(selector, styleProp, callback) {
   const scrollbarWidth = this.getWidth();</p>
<p>const manipulationCallBack = element =&gt; {
     if (element !== this._element &amp;&amp; window.innerWidth &gt; element.clientWidth + scrollbarWidth) {
       return;
     }</p>
<pre><code> this._saveInitialAttribute(element, styleProp);

 const calculatedValue = window.getComputedStyle(element)[styleProp];
 element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;
</code></pre>
<p>};</p>
<p>this._applyManipulationCallback(selector, manipulationCallBack);
 }</p>
<p>reset() {
   this._resetElementAttributes(this._element, &lsquo;overflow&rsquo;);</p>
<p>this._resetElementAttributes(this._element, &lsquo;paddingRight&rsquo;);</p>
<p>this._resetElementAttributes(SELECTOR_FIXED_CONTENT, &lsquo;paddingRight&rsquo;);</p>
<p>this._resetElementAttributes(SELECTOR_STICKY_CONTENT, &lsquo;marginRight&rsquo;);
 }</p>
<p>_saveInitialAttribute(element, styleProp) {
   const actualValue = element.style[styleProp];</p>
<p>if (actualValue) {
     Manipulator.setDataAttribute(element, styleProp, actualValue);
   }
 }</p>
<p>_resetElementAttributes(selector, styleProp) {
   const manipulationCallBack = element =&gt; {
     const value = Manipulator.getDataAttribute(element, styleProp);</p>
<pre><code> if (typeof value === 'undefined') {
   element.style.removeProperty(styleProp);
 } else {
   Manipulator.removeDataAttribute(element, styleProp);
   element.style[styleProp] = value;
 }
</code></pre>
<p>};</p>
<p>this._applyManipulationCallback(selector, manipulationCallBack);
 }</p>
<p>_applyManipulationCallback(selector, callBack) {
   if (isElement$1(selector)) {
     callBack(selector);
   } else {
     SelectorEngine.find(selector, this._element).forEach(callBack);
   }
 }</p>
<p>isOverflowing() {
   return this.getWidth() &gt; 0;
 }</p>
<p>}</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">util</span><span class="o">/</span><span class="nx">sanitizer</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-42'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-42'>#</a>
      </div>
      <p>const Default$7 = {
 className: &lsquo;modal-backdrop&rsquo;,
 isVisible: true,
 // if false, we use the backdrop helper without adding any element to the dom
 isAnimated: false,
 rootElement: &lsquo;body&rsquo;,
 // give the choice to place backdrop under different elements
 clickCallback: null
  };
  const DefaultType$7 = {
 className: &lsquo;string&rsquo;,
 isVisible: &lsquo;boolean&rsquo;,
 isAnimated: &lsquo;boolean&rsquo;,
 rootElement: &lsquo;(element|string)&rsquo;,
 clickCallback: &lsquo;(function|null)&rsquo;
  };
  const NAME$8 = &lsquo;backdrop&rsquo;;
  const CLASS_NAME_FADE$4 = &lsquo;fade&rsquo;;
  const CLASS_NAME_SHOW$5 = &lsquo;show&rsquo;;
  const EVENT_MOUSEDOWN = <code>mousedown.bs.${NAME$8}</code>;</p>
<p>class Backdrop {
 constructor(config) {
   this._config = this._getConfig(config);
   this._isAppended = false;
   this._element = null;
 }</p>
<p>show(callback) {
   if (!this._config.isVisible) {
     execute(callback);
     return;
   }</p>
<p>this._append();</p>
<p>if (this._config.isAnimated) {
     reflow(this._getElement());
   }</p>
<p>this._getElement().classList.add(CLASS_NAME_SHOW$5);</p>
<p>this._emulateAnimation(() =&gt; {
     execute(callback);
   });
 }</p>
<p>hide(callback) {
   if (!this._config.isVisible) {
     execute(callback);
     return;
   }</p>
<p>this._getElement().classList.remove(CLASS_NAME_SHOW$5);</p>
<p>this._emulateAnimation(() =&gt; {
     this.dispose();
     execute(callback);
   });
 } // Private</p>
<p>_getElement() {
   if (!this._element) {
     const backdrop = document.createElement(&lsquo;div&rsquo;);
     backdrop.className = this._config.className;</p>
<pre><code> if (this._config.isAnimated) {
   backdrop.classList.add(CLASS_NAME_FADE$4);
 }

 this._element = backdrop;
</code></pre>
<p>}</p>
<p>return this._element;
 }</p>
<p>_getConfig(config) {
   config = { &hellip;Default$7,
     &hellip;(typeof config === &lsquo;object&rsquo; ? config : {})
   }; // use getElement() with the default &ldquo;body&rdquo; to get a fresh Element on each instantiation</p>
<p>config.rootElement = getElement(config.rootElement);
   typeCheckConfig(NAME$8, config, DefaultType$7);
   return config;
 }</p>
<p>_append() {
   if (this._isAppended) {
     return;
   }</p>
<p>this._config.rootElement.append(this._getElement());</p>
<p>EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, () =&gt; {
     execute(this._config.clickCallback);
   });
   this._isAppended = true;
 }</p>
<p>dispose() {
   if (!this._isAppended) {
     return;
   }</p>
<p>EventHandler.off(this._element, EVENT_MOUSEDOWN);</p>
<p>this._element.remove();</p>
<p>this._isAppended = false;
 }</p>
<p>_emulateAnimation(callback) {
   executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
 }</p>
<p>}</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="nx">A</span> <span class="nx">pattern</span> <span class="nx">that</span> <span class="nx">recognizes</span> <span class="nx">a</span> <span class="nx">commonly</span> <span class="nx">useful</span> <span class="nx">subset</span> <span class="k">of</span> <span class="nx">URLs</span> <span class="nx">that</span> <span class="nx">are</span> <span class="nx">safe</span><span class="p">.</span>
   <span class="o">*</span>
   <span class="o">*</span> <span class="nx">Shoutout</span> <span class="nx">to</span> <span class="nx">Angular</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-43'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-43'>#</a>
      </div>
      <p>const Default$6 = {
 trapElement: null,
 // The element to trap focus inside of
 autofocus: true
  };
  const DefaultType$6 = {
 trapElement: &lsquo;element&rsquo;,
 autofocus: &lsquo;boolean&rsquo;
  };
  const NAME$7 = &lsquo;focustrap&rsquo;;
  const DATA_KEY$7 = &lsquo;bs.focustrap&rsquo;;
  const EVENT_KEY$7 = <code>.${DATA_KEY$7}</code>;
  const EVENT_FOCUSIN$1 = <code>focusin${EVENT_KEY$7}</code>;
  const EVENT_KEYDOWN_TAB = <code>keydown.tab${EVENT_KEY$7}</code>;
  const TAB_KEY = &lsquo;Tab&rsquo;;
  const TAB_NAV_FORWARD = &lsquo;forward&rsquo;;
  const TAB_NAV_BACKWARD = &lsquo;backward&rsquo;;</p>
<p>class FocusTrap {
 constructor(config) {
   this._config = this._getConfig(config);
   this._isActive = false;
   this._lastTabNavDirection = null;
 }</p>
<p>activate() {
   const {
     trapElement,
     autofocus
   } = this._config;</p>
<p>if (this._isActive) {
     return;
   }</p>
<p>if (autofocus) {
     trapElement.focus();
   }</p>
<p>EventHandler.off(document, EVENT_KEY$7); // guard against infinite focus loop</p>
<p>EventHandler.on(document, EVENT_FOCUSIN$1, event =&gt; this._handleFocusin(event));
   EventHandler.on(document, EVENT_KEYDOWN_TAB, event =&gt; this._handleKeydown(event));
   this._isActive = true;
 }</p>
<p>deactivate() {
   if (!this._isActive) {
     return;
   }</p>
<p>this._isActive = false;
   EventHandler.off(document, EVENT_KEY$7);
 } // Private</p>
<p>_handleFocusin(event) {
   const {
     target
   } = event;
   const {
     trapElement
   } = this._config;</p>
<p>if (target === document || target === trapElement || trapElement.contains(target)) {
     return;
   }</p>
<p>const elements = SelectorEngine.focusableChildren(trapElement);</p>
<p>if (elements.length === 0) {
     trapElement.focus();
   } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
     elements[elements.length - 1].focus();
   } else {
     elements[0].focus();
   }
 }</p>
<p>_handleKeydown(event) {
   if (event.key !== TAB_KEY) {
     return;
   }</p>
<p>this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
 }</p>
<p>_getConfig(config) {
   config = { &hellip;Default$6,
     &hellip;(typeof config === &lsquo;object&rsquo; ? config : {})
   };
   typeCheckConfig(NAME$7, config, DefaultType$6);
   return config;
 }</p>
<p>}</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="nx">A</span> <span class="nx">pattern</span> <span class="nx">that</span> <span class="nx">matches</span> <span class="nx">safe</span> <span class="nx">data</span> <span class="nx">URLs</span><span class="p">.</span> <span class="nx">Only</span> <span class="nx">matches</span> <span class="nx">image</span><span class="p">,</span> <span class="nx">video</span> <span class="nx">and</span> <span class="nx">audio</span> <span class="nx">types</span><span class="p">.</span>
   <span class="o">*</span>
   <span class="o">*</span> <span class="nx">Shoutout</span> <span class="nx">to</span> <span class="nx">Angular</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-44'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-44'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">tooltip</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-45'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-45'>#</a>
      </div>
      <p>const NAME$6 = &lsquo;modal&rsquo;;
  const DATA_KEY$6 = &lsquo;bs.modal&rsquo;;
  const EVENT_KEY$6 = <code>.${DATA_KEY$6}</code>;
  const DATA_API_KEY$3 = &lsquo;.data-api&rsquo;;
  const ESCAPE_KEY$1 = &lsquo;Escape&rsquo;;
  const Default$5 = {
 backdrop: true,
 keyboard: true,
 focus: true
  };
  const DefaultType$5 = {
 backdrop: &lsquo;(boolean|string)&rsquo;,
 keyboard: &lsquo;boolean&rsquo;,
 focus: &lsquo;boolean&rsquo;
  };
  const EVENT_HIDE$3 = <code>hide${EVENT_KEY$6}</code>;
  const EVENT_HIDE_PREVENTED = <code>hidePrevented${EVENT_KEY$6}</code>;
  const EVENT_HIDDEN$3 = <code>hidden${EVENT_KEY$6}</code>;
  const EVENT_SHOW$3 = <code>show${EVENT_KEY$6}</code>;
  const EVENT_SHOWN$3 = <code>shown${EVENT_KEY$6}</code>;
  const EVENT_RESIZE = <code>resize${EVENT_KEY$6}</code>;
  const EVENT_CLICK_DISMISS = <code>click.dismiss${EVENT_KEY$6}</code>;
  const EVENT_KEYDOWN_DISMISS$1 = <code>keydown.dismiss${EVENT_KEY$6}</code>;
  const EVENT_MOUSEUP_DISMISS = <code>mouseup.dismiss${EVENT_KEY$6}</code>;
  const EVENT_MOUSEDOWN_DISMISS = <code>mousedown.dismiss${EVENT_KEY$6}</code>;
  const EVENT_CLICK_DATA_API$2 = <code>click${EVENT_KEY$6}${DATA_API_KEY$3}</code>;
  const CLASS_NAME_OPEN = &lsquo;modal-open&rsquo;;
  const CLASS_NAME_FADE$3 = &lsquo;fade&rsquo;;
  const CLASS_NAME_SHOW$4 = &lsquo;show&rsquo;;
  const CLASS_NAME_STATIC = &lsquo;modal-static&rsquo;;
  const OPEN_SELECTOR$1 = &lsquo;.modal.show&rsquo;;
  const SELECTOR_DIALOG = &lsquo;.modal-dialog&rsquo;;
  const SELECTOR_MODAL_BODY = &lsquo;.modal-body&rsquo;;
  const SELECTOR_DATA_TOGGLE$2 = &lsquo;[data-bs-toggle=&rdquo;modal&rdquo;]&rsquo;;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-46'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-46'>#</a>
      </div>
      <p>class Modal extends BaseComponent {
 constructor(element, config) {
   super(element);
   this._config = this._getConfig(config);
   this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
   this._backdrop = this._initializeBackDrop();
   this._focustrap = this._initializeFocusTrap();
   this._isShown = false;
   this._ignoreBackdropClick = false;
   this._isTransitioning = false;
   this._scrollBar = new ScrollBarHelper();
 } // Getters</p>
<p>static get Default() {
   return Default$5;
 }</p>
<p>static get NAME() {
   return NAME$6;
 } // Public</p>
<p>toggle(relatedTarget) {
   return this._isShown ? this.hide() : this.show(relatedTarget);
 }</p>
<p>show(relatedTarget) {
   if (this._isShown || this._isTransitioning) {
     return;
   }</p>
<p>const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
     relatedTarget
   });</p>
<p>if (showEvent.defaultPrevented) {
     return;
   }</p>
<p>this._isShown = true;</p>
<p>if (this._isAnimated()) {
     this._isTransitioning = true;
   }</p>
<p>this._scrollBar.hide();</p>
<p>document.body.classList.add(CLASS_NAME_OPEN);</p>
<p>this._adjustDialog();</p>
<p>this._setEscapeEvent();</p>
<p>this._setResizeEvent();</p>
<p>EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () =&gt; {
     EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, event =&gt; {
       if (event.target === this._element) {
         this._ignoreBackdropClick = true;
       }
     });
   });</p>
<p>this._showBackdrop(() =&gt; this._showElement(relatedTarget));
 }</p>
<p>hide() {
   if (!this._isShown || this._isTransitioning) {
     return;
   }</p>
<p>const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);</p>
<p>if (hideEvent.defaultPrevented) {
     return;
   }</p>
<p>this._isShown = false;</p>
<p>const isAnimated = this._isAnimated();</p>
<p>if (isAnimated) {
     this._isTransitioning = true;
   }</p>
<p>this._setEscapeEvent();</p>
<p>this._setResizeEvent();</p>
<p>this._focustrap.deactivate();</p>
<p>this._element.classList.remove(CLASS_NAME_SHOW$4);</p>
<p>EventHandler.off(this._element, EVENT_CLICK_DISMISS);
   EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);</p>
<p>this._queueCallback(() =&gt; this._hideModal(), this._element, isAnimated);
 }</p>
<p>dispose() {
   [window, this._dialog].forEach(htmlElement =&gt; EventHandler.off(htmlElement, EVENT_KEY$6));</p>
<p>this._backdrop.dispose();</p>
<p>this._focustrap.deactivate();</p>
<p>super.dispose();
 }</p>
<p>handleUpdate() {
   this._adjustDialog();
 } // Private</p>
<p>_initializeBackDrop() {
   return new Backdrop({
     isVisible: Boolean(this._config.backdrop),
     // &lsquo;static&rsquo; option will be translated to true, and booleans will keep their value
     isAnimated: this._isAnimated()
   });
 }</p>
<p>_initializeFocusTrap() {
   return new FocusTrap({
     trapElement: this._element
   });
 }</p>
<p>_getConfig(config) {
   config = { &hellip;Default$5,
     &hellip;Manipulator.getDataAttributes(this._element),
     &hellip;(typeof config === &lsquo;object&rsquo; ? config : {})
   };
   typeCheckConfig(NAME$6, config, DefaultType$5);
   return config;
 }</p>
<p>_showElement(relatedTarget) {
   const isAnimated = this._isAnimated();</p>
<p>const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);</p>
<p>if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
     // Don&rsquo;t move modal&rsquo;s DOM position
     document.body.append(this._element);
   }</p>
<p>this._element.style.display = &lsquo;block&rsquo;;</p>
<p>this._element.removeAttribute(&lsquo;aria-hidden&rsquo;);</p>
<p>this._element.setAttribute(&lsquo;aria-modal&rsquo;, true);</p>
<p>this._element.setAttribute(&lsquo;role&rsquo;, &lsquo;dialog&rsquo;);</p>
<p>this._element.scrollTop = 0;</p>
<p>if (modalBody) {
     modalBody.scrollTop = 0;
   }</p>
<p>if (isAnimated) {
     reflow(this._element);
   }</p>
<p>this._element.classList.add(CLASS_NAME_SHOW$4);</p>
<p>const transitionComplete = () =&gt; {
     if (this._config.focus) {
       this._focustrap.activate();
     }</p>
<pre><code> this._isTransitioning = false;
 EventHandler.trigger(this._element, EVENT_SHOWN$3, {
   relatedTarget
 });
</code></pre>
<p>};</p>
<p>this._queueCallback(transitionComplete, this._dialog, isAnimated);
 }</p>
<p>_setEscapeEvent() {
   if (this._isShown) {
     EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event =&gt; {
       if (this._config.keyboard &amp;&amp; event.key === ESCAPE_KEY$1) {
         event.preventDefault();
         this.hide();
       } else if (!this._config.keyboard &amp;&amp; event.key === ESCAPE_KEY$1) {
         this._triggerBackdropTransition();
       }
     });
   } else {
     EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1);
   }
 }</p>
<p>_setResizeEvent() {
   if (this._isShown) {
     EventHandler.on(window, EVENT_RESIZE, () =&gt; this._adjustDialog());
   } else {
     EventHandler.off(window, EVENT_RESIZE);
   }
 }</p>
<p>_hideModal() {
   this._element.style.display = &lsquo;none&rsquo;;</p>
<p>this._element.setAttribute(&lsquo;aria-hidden&rsquo;, true);</p>
<p>this._element.removeAttribute(&lsquo;aria-modal&rsquo;);</p>
<p>this._element.removeAttribute(&lsquo;role&rsquo;);</p>
<p>this._isTransitioning = false;</p>
<p>this._backdrop.hide(() =&gt; {
     document.body.classList.remove(CLASS_NAME_OPEN);</p>
<pre><code> this._resetAdjustments();

 this._scrollBar.reset();

 EventHandler.trigger(this._element, EVENT_HIDDEN$3);
</code></pre>
<p>});
 }</p>
<p>_showBackdrop(callback) {
   EventHandler.on(this._element, EVENT_CLICK_DISMISS, event =&gt; {
     if (this._ignoreBackdropClick) {
       this._ignoreBackdropClick = false;
       return;
     }</p>
<pre><code> if (event.target !== event.currentTarget) {
   return;
 }

 if (this._config.backdrop === true) {
   this.hide();
 } else if (this._config.backdrop === 'static') {
   this._triggerBackdropTransition();
 }
</code></pre>
<p>});</p>
<p>this._backdrop.show(callback);
 }</p>
<p>_isAnimated() {
   return this._element.classList.contains(CLASS_NAME_FADE$3);
 }</p>
<p>_triggerBackdropTransition() {
   const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);</p>
<p>if (hideEvent.defaultPrevented) {
     return;
   }</p>
<p>const {
     classList,
     scrollHeight,
     style
   } = this._element;
   const isModalOverflowing = scrollHeight &gt; document.documentElement.clientHeight; // return if the following background transition hasn&rsquo;t yet completed</p>
<p>if (!isModalOverflowing &amp;&amp; style.overflowY === &lsquo;hidden&rsquo; || classList.contains(CLASS_NAME_STATIC)) {
     return;
   }</p>
<p>if (!isModalOverflowing) {
     style.overflowY = &lsquo;hidden&rsquo;;
   }</p>
<p>classList.add(CLASS_NAME_STATIC);</p>
<p>this._queueCallback(() =&gt; {
     classList.remove(CLASS_NAME_STATIC);</p>
<pre><code> if (!isModalOverflowing) {
   this._queueCallback(() =&gt; {
     style.overflowY = '';
   }, this._dialog);
 }
</code></pre>
<p>}, this._dialog);</p>
<p>this._element.focus();
 } // ----------------------------------------------------------------------
 // the following methods are used to handle overflowing modals
 // ----------------------------------------------------------------------</p>
<p>_adjustDialog() {
   const isModalOverflowing = this._element.scrollHeight &gt; document.documentElement.clientHeight;</p>
<p>const scrollbarWidth = this._scrollBar.getWidth();</p>
<p>const isBodyOverflowing = scrollbarWidth &gt; 0;</p>
<p>if (!isBodyOverflowing &amp;&amp; isModalOverflowing &amp;&amp; !isRTL() || isBodyOverflowing &amp;&amp; !isModalOverflowing &amp;&amp; isRTL()) {
     this._element.style.paddingLeft = <code>${scrollbarWidth}px</code>;
   }</p>
<p>if (isBodyOverflowing &amp;&amp; !isModalOverflowing &amp;&amp; !isRTL() || !isBodyOverflowing &amp;&amp; isModalOverflowing &amp;&amp; isRTL()) {
     this._element.style.paddingRight = <code>${scrollbarWidth}px</code>;
   }
 }</p>
<p>_resetAdjustments() {
   this._element.style.paddingLeft = &lsquo;&rsquo;;
   this._element.style.paddingRight = &lsquo;&rsquo;;
 } // Static</p>
<p>static jQueryInterface(config, relatedTarget) {
   return this.each(function () {
     const data = Modal.getOrCreateInstance(this, config);</p>
<pre><code> if (typeof config !== 'string') {
   return;
 }

 if (typeof data[config] === 'undefined') {
   throw new TypeError(`No method named "${config}"`);
 }

 data[config](relatedTarget);
</code></pre>
<p>});
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-47'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-47'>#</a>
      </div>
      <p>EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
 const target = getElementFromSelector(this);</p>
<p>if ([&lsquo;A&rsquo;, &lsquo;AREA&rsquo;].includes(this.tagName)) {
   event.preventDefault();
 }</p>
<p>EventHandler.one(target, EVENT_SHOW$3, showEvent =&gt; {
   if (showEvent.defaultPrevented) {
     // only register focus restorer if modal will actually get shown
     return;
   }</p>
<p>EventHandler.one(target, EVENT_HIDDEN$3, () =&gt; {
     if (isVisible(this)) {
       this.focus();
     }
   });
 }); // avoid conflict when clicking moddal toggler while another one is open</p>
<p>const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);</p>
<p>if (allReadyOpen) {
   Modal.getInstance(allReadyOpen).hide();
 }</p>
<p>const data = Modal.getOrCreateInstance(target);
 data.toggle(this);
  });
  enableDismissTrigger(Modal);
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Tooltip</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-48'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-48'>#</a>
      </div>
      <p>defineJQueryPlugin(Modal);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">popover</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-49'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-49'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-50'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-50'>#</a>
      </div>
      <p>const NAME$5 = &lsquo;offcanvas&rsquo;;
  const DATA_KEY$5 = &lsquo;bs.offcanvas&rsquo;;
  const EVENT_KEY$5 = <code>.${DATA_KEY$5}</code>;
  const DATA_API_KEY$2 = &lsquo;.data-api&rsquo;;
  const EVENT_LOAD_DATA_API$1 = <code>load${EVENT_KEY$5}${DATA_API_KEY$2}</code>;
  const ESCAPE_KEY = &lsquo;Escape&rsquo;;
  const Default$4 = {
 backdrop: true,
 keyboard: true,
 scroll: false
  };
  const DefaultType$4 = {
 backdrop: &lsquo;boolean&rsquo;,
 keyboard: &lsquo;boolean&rsquo;,
 scroll: &lsquo;boolean&rsquo;
  };
  const CLASS_NAME_SHOW$3 = &lsquo;show&rsquo;;
  const CLASS_NAME_BACKDROP = &lsquo;offcanvas-backdrop&rsquo;;
  const OPEN_SELECTOR = &lsquo;.offcanvas.show&rsquo;;
  const EVENT_SHOW$2 = <code>show${EVENT_KEY$5}</code>;
  const EVENT_SHOWN$2 = <code>shown${EVENT_KEY$5}</code>;
  const EVENT_HIDE$2 = <code>hide${EVENT_KEY$5}</code>;
  const EVENT_HIDDEN$2 = <code>hidden${EVENT_KEY$5}</code>;
  const EVENT_CLICK_DATA_API$1 = <code>click${EVENT_KEY$5}${DATA_API_KEY$2}</code>;
  const EVENT_KEYDOWN_DISMISS = <code>keydown.dismiss${EVENT_KEY$5}</code>;
  const SELECTOR_DATA_TOGGLE$1 = &lsquo;[data-bs-toggle=&rdquo;offcanvas&rdquo;]&rsquo;;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-51'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-51'>#</a>
      </div>
      <p>class Offcanvas extends BaseComponent {
 constructor(element, config) {
   super(element);
   this._config = this._getConfig(config);
   this._isShown = false;
   this._backdrop = this._initializeBackDrop();
   this._focustrap = this._initializeFocusTrap();</p>
<p>this._addEventListeners();
 } // Getters</p>
<p>static get NAME() {
   return NAME$5;
 }</p>
<p>static get Default() {
   return Default$4;
 } // Public</p>
<p>toggle(relatedTarget) {
   return this._isShown ? this.hide() : this.show(relatedTarget);
 }</p>
<p>show(relatedTarget) {
   if (this._isShown) {
     return;
   }</p>
<p>const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {
     relatedTarget
   });</p>
<p>if (showEvent.defaultPrevented) {
     return;
   }</p>
<p>this._isShown = true;
   this._element.style.visibility = &lsquo;visible&rsquo;;</p>
<p>this._backdrop.show();</p>
<p>if (!this._config.scroll) {
     new ScrollBarHelper().hide();
   }</p>
<p>this._element.removeAttribute(&lsquo;aria-hidden&rsquo;);</p>
<p>this._element.setAttribute(&lsquo;aria-modal&rsquo;, true);</p>
<p>this._element.setAttribute(&lsquo;role&rsquo;, &lsquo;dialog&rsquo;);</p>
<p>this._element.classList.add(CLASS_NAME_SHOW$3);</p>
<p>const completeCallBack = () =&gt; {
     if (!this._config.scroll) {
       this._focustrap.activate();
     }</p>
<pre><code> EventHandler.trigger(this._element, EVENT_SHOWN$2, {
   relatedTarget
 });
</code></pre>
<p>};</p>
<p>this._queueCallback(completeCallBack, this._element, true);
 }</p>
<p>hide() {
   if (!this._isShown) {
     return;
   }</p>
<p>const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);</p>
<p>if (hideEvent.defaultPrevented) {
     return;
   }</p>
<p>this._focustrap.deactivate();</p>
<p>this._element.blur();</p>
<p>this._isShown = false;</p>
<p>this._element.classList.remove(CLASS_NAME_SHOW$3);</p>
<p>this._backdrop.hide();</p>
<p>const completeCallback = () =&gt; {
     this._element.setAttribute(&lsquo;aria-hidden&rsquo;, true);</p>
<pre><code> this._element.removeAttribute('aria-modal');

 this._element.removeAttribute('role');

 this._element.style.visibility = 'hidden';

 if (!this._config.scroll) {
   new ScrollBarHelper().reset();
 }

 EventHandler.trigger(this._element, EVENT_HIDDEN$2);
</code></pre>
<p>};</p>
<p>this._queueCallback(completeCallback, this._element, true);
 }</p>
<p>dispose() {
   this._backdrop.dispose();</p>
<p>this._focustrap.deactivate();</p>
<p>super.dispose();
 } // Private</p>
<p>_getConfig(config) {
   config = { &hellip;Default$4,
     &hellip;Manipulator.getDataAttributes(this._element),
     &hellip;(typeof config === &lsquo;object&rsquo; ? config : {})
   };
   typeCheckConfig(NAME$5, config, DefaultType$4);
   return config;
 }</p>
<p>_initializeBackDrop() {
   return new Backdrop({
     className: CLASS_NAME_BACKDROP,
     isVisible: this._config.backdrop,
     isAnimated: true,
     rootElement: this._element.parentNode,
     clickCallback: () =&gt; this.hide()
   });
 }</p>
<p>_initializeFocusTrap() {
   return new FocusTrap({
     trapElement: this._element
   });
 }</p>
<p>_addEventListeners() {
   EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event =&gt; {
     if (this._config.keyboard &amp;&amp; event.key === ESCAPE_KEY) {
       this.hide();
     }
   });
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const data = Offcanvas.getOrCreateInstance(this, config);</p>
<pre><code> if (typeof config !== 'string') {
   return;
 }

 if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
   throw new TypeError(`No method named "${config}"`);
 }

 data[config](this);
</code></pre>
<p>});
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Popover</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-52'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-52'>#</a>
      </div>
      <p>EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
 const target = getElementFromSelector(this);</p>
<p>if ([&lsquo;A&rsquo;, &lsquo;AREA&rsquo;].includes(this.tagName)) {
   event.preventDefault();
 }</p>
<p>if (isDisabled(this)) {
   return;
 }</p>
<p>EventHandler.one(target, EVENT_HIDDEN$2, () =&gt; {
   // focus on trigger when it is closed
   if (isVisible(this)) {
     this.focus();
   }
 }); // avoid conflict when clicking a toggler of an offcanvas, while another is open</p>
<p>const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);</p>
<p>if (allReadyOpen &amp;&amp; allReadyOpen !== target) {
   Offcanvas.getInstance(allReadyOpen).hide();
 }</p>
<p>const data = Offcanvas.getOrCreateInstance(target);
 data.toggle(this);
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () =&gt; SelectorEngine.find(OPEN_SELECTOR).forEach(el =&gt; Offcanvas.getOrCreateInstance(el).show()));
  enableDismissTrigger(Offcanvas);
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">scrollspy</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-53'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-53'>#</a>
      </div>
      <p>defineJQueryPlugin(Offcanvas);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-54'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-54'>#</a>
      </div>
      <p>const uriAttributes = new Set([&lsquo;background&rsquo;, &lsquo;cite&rsquo;, &lsquo;href&rsquo;, &lsquo;itemtype&rsquo;, &lsquo;longdesc&rsquo;, &lsquo;poster&rsquo;, &lsquo;src&rsquo;, &lsquo;xlink:href&rsquo;]);
  const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-55'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-55'>#</a>
      </div>
      <p>const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&amp;/:?]*(?:[#/?]|$))/i;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Data</span> <span class="nx">Api</span> <span class="nx">implementation</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-56'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-56'>#</a>
      </div>
      <p>const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;</p>
<p>const allowedAttribute = (attribute, allowedAttributeList) =&gt; {
 const attributeName = attribute.nodeName.toLowerCase();</p>
<p>if (allowedAttributeList.includes(attributeName)) {
   if (uriAttributes.has(attributeName)) {
     return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
   }</p>
<p>return true;
 }</p>
<p>const regExp = allowedAttributeList.filter(attributeRegex =&gt; attributeRegex instanceof RegExp); // Check if a regular expression validates the attribute.</p>
<p>for (let i = 0, len = regExp.length; i &lt; len; i++) {
   if (regExp[i].test(attributeName)) {
     return true;
   }
 }</p>
<p>return false;
  };</p>
<p>const DefaultAllowlist = {
 // Global attributes allowed on any supplied element below.
 &lsquo;*&rsquo;: [&lsquo;class&rsquo;, &lsquo;dir&rsquo;, &lsquo;id&rsquo;, &lsquo;lang&rsquo;, &lsquo;role&rsquo;, ARIA_ATTRIBUTE_PATTERN],
 a: [&lsquo;target&rsquo;, &lsquo;href&rsquo;, &lsquo;title&rsquo;, &lsquo;rel&rsquo;],
 area: [],
 b: [],
 br: [],
 col: [],
 code: [],
 div: [],
 em: [],
 hr: [],
 h1: [],
 h2: [],
 h3: [],
 h4: [],
 h5: [],
 h6: [],
 i: [],
 img: [&lsquo;src&rsquo;, &lsquo;srcset&rsquo;, &lsquo;alt&rsquo;, &lsquo;title&rsquo;, &lsquo;width&rsquo;, &lsquo;height&rsquo;],
 li: [],
 ol: [],
 p: [],
 pre: [],
 s: [],
 small: [],
 span: [],
 sub: [],
 sup: [],
 strong: [],
 u: [],
 ul: []
  };
  function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
 if (!unsafeHtml.length) {
   return unsafeHtml;
 }</p>
<p>if (sanitizeFn &amp;&amp; typeof sanitizeFn === &lsquo;function&rsquo;) {
   return sanitizeFn(unsafeHtml);
 }</p>
<p>const domParser = new window.DOMParser();
 const createdDocument = domParser.parseFromString(unsafeHtml, &lsquo;text/html&rsquo;);
 const elements = [].concat(&hellip;createdDocument.body.querySelectorAll(&lsquo;*&rsquo;));</p>
<p>for (let i = 0, len = elements.length; i &lt; len; i++) {
   const element = elements[i];
   const elementName = element.nodeName.toLowerCase();</p>
<p>if (!Object.keys(allowList).includes(elementName)) {
     element.remove();
     continue;
   }</p>
<p>const attributeList = [].concat(&hellip;element.attributes);
   const allowedAttributes = [].concat(allowList[&lsquo;*&rsquo;] || [], allowList[elementName] || []);
   attributeList.forEach(attribute =&gt; {
     if (!allowedAttribute(attribute, allowedAttributes)) {
       element.removeAttribute(attribute.nodeName);
     }
   });
 }</p>
<p>return createdDocument.body.innerHTML;
  }</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">ScrollSpy</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-57'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-57'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-58'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-58'>#</a>
      </div>
      <p>const NAME$4 = &lsquo;tooltip&rsquo;;
  const DATA_KEY$4 = &lsquo;bs.tooltip&rsquo;;
  const EVENT_KEY$4 = <code>.${DATA_KEY$4}</code>;
  const CLASS_PREFIX$1 = &lsquo;bs-tooltip&rsquo;;
  const DISALLOWED_ATTRIBUTES = new Set([&lsquo;sanitize&rsquo;, &lsquo;allowList&rsquo;, &lsquo;sanitizeFn&rsquo;]);
  const DefaultType$3 = {
 animation: &lsquo;boolean&rsquo;,
 template: &lsquo;string&rsquo;,
 title: &lsquo;(string|element|function)&rsquo;,
 trigger: &lsquo;string&rsquo;,
 delay: &lsquo;(number|object)&rsquo;,
 html: &lsquo;boolean&rsquo;,
 selector: &lsquo;(string|boolean)&rsquo;,
 placement: &lsquo;(string|function)&rsquo;,
 offset: &lsquo;(array|string|function)&rsquo;,
 container: &lsquo;(string|element|boolean)&rsquo;,
 fallbackPlacements: &lsquo;array&rsquo;,
 boundary: &lsquo;(string|element)&rsquo;,
 customClass: &lsquo;(string|function)&rsquo;,
 sanitize: &lsquo;boolean&rsquo;,
 sanitizeFn: &lsquo;(null|function)&rsquo;,
 allowList: &lsquo;object&rsquo;,
 popperConfig: &lsquo;(null|object|function)&rsquo;
  };
  const AttachmentMap = {
 AUTO: &lsquo;auto&rsquo;,
 TOP: &lsquo;top&rsquo;,
 RIGHT: isRTL() ? &lsquo;left&rsquo; : &lsquo;right&rsquo;,
 BOTTOM: &lsquo;bottom&rsquo;,
 LEFT: isRTL() ? &lsquo;right&rsquo; : &lsquo;left&rsquo;
  };
  const Default$3 = {
 animation: true,
 template: &lsquo;<div class="tooltip" role="tooltip">&lsquo; + &lsquo;<div class="tooltip-arrow"></div>&lsquo; + &lsquo;<div class="tooltip-inner"></div>&lsquo; + &lsquo;</div>&lsquo;,
 trigger: &lsquo;hover focus&rsquo;,
 title: &lsquo;&rsquo;,
 delay: 0,
 html: false,
 selector: false,
 placement: &lsquo;top&rsquo;,
 offset: [0, 0],
 container: false,
 fallbackPlacements: [&lsquo;top&rsquo;, &lsquo;right&rsquo;, &lsquo;bottom&rsquo;, &lsquo;left&rsquo;],
 boundary: &lsquo;clippingParents&rsquo;,
 customClass: &lsquo;&rsquo;,
 sanitize: true,
 sanitizeFn: null,
 allowList: DefaultAllowlist,
 popperConfig: null
  };
  const Event$2 = {
 HIDE: <code>hide${EVENT_KEY$4}</code>,
 HIDDEN: <code>hidden${EVENT_KEY$4}</code>,
 SHOW: <code>show${EVENT_KEY$4}</code>,
 SHOWN: <code>shown${EVENT_KEY$4}</code>,
 INSERTED: <code>inserted${EVENT_KEY$4}</code>,
 CLICK: <code>click${EVENT_KEY$4}</code>,
 FOCUSIN: <code>focusin${EVENT_KEY$4}</code>,
 FOCUSOUT: <code>focusout${EVENT_KEY$4}</code>,
 MOUSEENTER: <code>mouseenter${EVENT_KEY$4}</code>,
 MOUSELEAVE: <code>mouseleave${EVENT_KEY$4}</code>
  };
  const CLASS_NAME_FADE$2 = &lsquo;fade&rsquo;;
  const CLASS_NAME_MODAL = &lsquo;modal&rsquo;;
  const CLASS_NAME_SHOW$2 = &lsquo;show&rsquo;;
  const HOVER_STATE_SHOW = &lsquo;show&rsquo;;
  const HOVER_STATE_OUT = &lsquo;out&rsquo;;
  const SELECTOR_TOOLTIP_INNER = &lsquo;.tooltip-inner&rsquo;;
  const SELECTOR_MODAL = <code>.${CLASS_NAME_MODAL}</code>;
  const EVENT_MODAL_HIDE = &lsquo;hide.bs.modal&rsquo;;
  const TRIGGER_HOVER = &lsquo;hover&rsquo;;
  const TRIGGER_FOCUS = &lsquo;focus&rsquo;;
  const TRIGGER_CLICK = &lsquo;click&rsquo;;
  const TRIGGER_MANUAL = &lsquo;manual&rsquo;;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-59'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-59'>#</a>
      </div>
      <p>class Tooltip extends BaseComponent {
 constructor(element, config) {
   if (typeof Popper === &lsquo;undefined&rsquo;) {
     throw new TypeError(&lsquo;Bootstrap's tooltips require Popper (https://popper.js.org)&rsquo;);
   }</p>
<p>super(element); // private</p>
<p>this._isEnabled = true;
   this._timeout = 0;
   this._hoverState = &lsquo;&rsquo;;
   this._activeTrigger = {};
   this._popper = null; // Protected</p>
<p>this._config = this._getConfig(config);
   this.tip = null;</p>
<p>this._setListeners();
 } // Getters</p>
<p>static get Default() {
   return Default$3;
 }</p>
<p>static get NAME() {
   return NAME$4;
 }</p>
<p>static get Event() {
   return Event$2;
 }</p>
<p>static get DefaultType() {
   return DefaultType$3;
 } // Public</p>
<p>enable() {
   this._isEnabled = true;
 }</p>
<p>disable() {
   this._isEnabled = false;
 }</p>
<p>toggleEnabled() {
   this._isEnabled = !this._isEnabled;
 }</p>
<p>toggle(event) {
   if (!this._isEnabled) {
     return;
   }</p>
<p>if (event) {
     const context = this._initializeOnDelegatedTarget(event);</p>
<pre><code> context._activeTrigger.click = !context._activeTrigger.click;

 if (context._isWithActiveTrigger()) {
   context._enter(null, context);
 } else {
   context._leave(null, context);
 }
</code></pre>
<p>} else {
     if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$2)) {
       this._leave(null, this);</p>
<pre><code>   return;
 }

 this._enter(null, this);
</code></pre>
<p>}
 }</p>
<p>dispose() {
   clearTimeout(this._timeout);
   EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);</p>
<p>if (this.tip) {
     this.tip.remove();
   }</p>
<p>this._disposePopper();</p>
<p>super.dispose();
 }</p>
<p>show() {
   if (this._element.style.display === &lsquo;none&rsquo;) {
     throw new Error(&lsquo;Please use show on visible elements&rsquo;);
   }</p>
<p>if (!(this.isWithContent() &amp;&amp; this._isEnabled)) {
     return;
   }</p>
<p>const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);
   const shadowRoot = findShadowRoot(this._element);
   const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);</p>
<p>if (showEvent.defaultPrevented || !isInTheDom) {
     return;
   } // A trick to recreate a tooltip in case a new title is given by using the NOT documented <code>data-bs-original-title</code>
   // This will be removed later in favor of a <code>setContent</code> method</p>
<p>if (this.constructor.NAME === &lsquo;tooltip&rsquo; &amp;&amp; this.tip &amp;&amp; this.getTitle() !== this.tip.querySelector(SELECTOR_TOOLTIP_INNER).innerHTML) {
     this._disposePopper();</p>
<pre><code> this.tip.remove();
 this.tip = null;
</code></pre>
<p>}</p>
<p>const tip = this.getTipElement();
   const tipId = getUID(this.constructor.NAME);
   tip.setAttribute(&lsquo;id&rsquo;, tipId);</p>
<p>this._element.setAttribute(&lsquo;aria-describedby&rsquo;, tipId);</p>
<p>if (this._config.animation) {
     tip.classList.add(CLASS_NAME_FADE$2);
   }</p>
<p>const placement = typeof this._config.placement === &lsquo;function&rsquo; ? this._config.placement.call(this, tip, this._element) : this._config.placement;</p>
<p>const attachment = this._getAttachment(placement);</p>
<p>this._addAttachmentClass(attachment);</p>
<p>const {
     container
   } = this._config;
   Data.set(tip, this.constructor.DATA_KEY, this);</p>
<p>if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
     container.append(tip);
     EventHandler.trigger(this._element, this.constructor.Event.INSERTED);
   }</p>
<p>if (this._popper) {
     this._popper.update();
   } else {
     this._popper = createPopper(this._element, tip, this._getPopperConfig(attachment));
   }</p>
<p>tip.classList.add(CLASS_NAME_SHOW$2);</p>
<p>const customClass = this._resolvePossibleFunction(this._config.customClass);</p>
<p>if (customClass) {
     tip.classList.add(&hellip;customClass.split(&lsquo; &lsquo;));
   } // If this is a touch-enabled device we add extra
   // empty mouseover listeners to the body&rsquo;s immediate children;
   // only needed because of broken event delegation on iOS
   // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html</p>
<p>if (&lsquo;ontouchstart&rsquo; in document.documentElement) {
     [].concat(&hellip;document.body.children).forEach(element =&gt; {
       EventHandler.on(element, &lsquo;mouseover&rsquo;, noop);
     });
   }</p>
<p>const complete = () =&gt; {
     const prevHoverState = this._hoverState;
     this._hoverState = null;
     EventHandler.trigger(this._element, this.constructor.Event.SHOWN);</p>
<pre><code> if (prevHoverState === HOVER_STATE_OUT) {
   this._leave(null, this);
 }
</code></pre>
<p>};</p>
<p>const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);</p>
<p>this._queueCallback(complete, this.tip, isAnimated);
 }</p>
<p>hide() {
   if (!this._popper) {
     return;
   }</p>
<p>const tip = this.getTipElement();</p>
<p>const complete = () =&gt; {
     if (this._isWithActiveTrigger()) {
       return;
     }</p>
<pre><code> if (this._hoverState !== HOVER_STATE_SHOW) {
   tip.remove();
 }

 this._cleanTipClass();

 this._element.removeAttribute('aria-describedby');

 EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);

 this._disposePopper();
</code></pre>
<p>};</p>
<p>const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);</p>
<p>if (hideEvent.defaultPrevented) {
     return;
   }</p>
<p>tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra
   // empty mouseover listeners we added for iOS support</p>
<p>if (&lsquo;ontouchstart&rsquo; in document.documentElement) {
     [].concat(&hellip;document.body.children).forEach(element =&gt; EventHandler.off(element, &lsquo;mouseover&rsquo;, noop));
   }</p>
<p>this._activeTrigger[TRIGGER_CLICK] = false;
   this._activeTrigger[TRIGGER_FOCUS] = false;
   this._activeTrigger[TRIGGER_HOVER] = false;
   const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);</p>
<p>this._queueCallback(complete, this.tip, isAnimated);</p>
<p>this._hoverState = &lsquo;&rsquo;;
 }</p>
<p>update() {
   if (this._popper !== null) {
     this._popper.update();
   }
 } // Protected</p>
<p>isWithContent() {
   return Boolean(this.getTitle());
 }</p>
<p>getTipElement() {
   if (this.tip) {
     return this.tip;
   }</p>
<p>const element = document.createElement(&lsquo;div&rsquo;);
   element.innerHTML = this._config.template;
   const tip = element.children[0];
   this.setContent(tip);
   tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
   this.tip = tip;
   return this.tip;
 }</p>
<p>setContent(tip) {
   this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TOOLTIP_INNER);
 }</p>
<p>_sanitizeAndSetContent(template, content, selector) {
   const templateElement = SelectorEngine.findOne(selector, template);</p>
<p>if (!content &amp;&amp; templateElement) {
     templateElement.remove();
     return;
   } // we use append for html objects to maintain js events</p>
<p>this.setElementContent(templateElement, content);
 }</p>
<p>setElementContent(element, content) {
   if (element === null) {
     return;
   }</p>
<p>if (isElement$1(content)) {
     content = getElement(content); // content is a DOM node or a jQuery</p>
<pre><code> if (this._config.html) {
   if (content.parentNode !== element) {
     element.innerHTML = '';
     element.append(content);
   }
 } else {
   element.textContent = content.textContent;
 }

 return;
</code></pre>
<p>}</p>
<p>if (this._config.html) {
     if (this._config.sanitize) {
       content = sanitizeHtml(content, this._config.allowList, this._config.sanitizeFn);
     }</p>
<pre><code> element.innerHTML = content;
</code></pre>
<p>} else {
     element.textContent = content;
   }
 }</p>
<p>getTitle() {
   const title = this._element.getAttribute(&lsquo;data-bs-original-title&rsquo;) || this._config.title;</p>
<p>return this._resolvePossibleFunction(title);
 }</p>
<p>updateAttachment(attachment) {
   if (attachment === &lsquo;right&rsquo;) {
     return &lsquo;end&rsquo;;
   }</p>
<p>if (attachment === &lsquo;left&rsquo;) {
     return &lsquo;start&rsquo;;
   }</p>
<p>return attachment;
 } // Private</p>
<p>_initializeOnDelegatedTarget(event, context) {
   return context || this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
 }</p>
<p>_getOffset() {
   const {
     offset
   } = this._config;</p>
<p>if (typeof offset === &lsquo;string&rsquo;) {
     return offset.split(&lsquo;,&rsquo;).map(val =&gt; Number.parseInt(val, 10));
   }</p>
<p>if (typeof offset === &lsquo;function&rsquo;) {
     return popperData =&gt; offset(popperData, this._element);
   }</p>
<p>return offset;
 }</p>
<p>_resolvePossibleFunction(content) {
   return typeof content === &lsquo;function&rsquo; ? content.call(this._element) : content;
 }</p>
<p>_getPopperConfig(attachment) {
   const defaultBsPopperConfig = {
     placement: attachment,
     modifiers: [{
       name: &lsquo;flip&rsquo;,
       options: {
         fallbackPlacements: this._config.fallbackPlacements
       }
     }, {
       name: &lsquo;offset&rsquo;,
       options: {
         offset: this._getOffset()
       }
     }, {
       name: &lsquo;preventOverflow&rsquo;,
       options: {
         boundary: this._config.boundary
       }
     }, {
       name: &lsquo;arrow&rsquo;,
       options: {
         element: <code>.${this.constructor.NAME}-arrow</code>
       }
     }, {
       name: &lsquo;onChange&rsquo;,
       enabled: true,
       phase: &lsquo;afterWrite&rsquo;,
       fn: data =&gt; this._handlePopperPlacementChange(data)
     }],
     onFirstUpdate: data =&gt; {
       if (data.options.placement !== data.placement) {
         this._handlePopperPlacementChange(data);
       }
     }
   };
   return { &hellip;defaultBsPopperConfig,
     &hellip;(typeof this._config.popperConfig === &lsquo;function&rsquo; ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)
   };
 }</p>
<p>_addAttachmentClass(attachment) {
   this.getTipElement().classList.add(<code>${this._getBasicClassPrefix()}-${this.updateAttachment(attachment)}</code>);
 }</p>
<p>_getAttachment(placement) {
   return AttachmentMap[placement.toUpperCase()];
 }</p>
<p>_setListeners() {
   const triggers = this._config.trigger.split(&lsquo; &lsquo;);</p>
<p>triggers.forEach(trigger =&gt; {
     if (trigger === &lsquo;click&rsquo;) {
       EventHandler.on(this._element, this.constructor.Event.CLICK, this._config.selector, event =&gt; this.toggle(event));
     } else if (trigger !== TRIGGER_MANUAL) {
       const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;
       const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
       EventHandler.on(this._element, eventIn, this._config.selector, event =&gt; this._enter(event));
       EventHandler.on(this._element, eventOut, this._config.selector, event =&gt; this._leave(event));
     }
   });</p>
<p>this._hideModalHandler = () =&gt; {
     if (this._element) {
       this.hide();
     }
   };</p>
<p>EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);</p>
<p>if (this._config.selector) {
     this._config = { &hellip;this._config,
       trigger: &lsquo;manual&rsquo;,
       selector: &lsquo;&rsquo;
     };
   } else {
     this._fixTitle();
   }
 }</p>
<p>_fixTitle() {
   const title = this._element.getAttribute(&lsquo;title&rsquo;);</p>
<p>const originalTitleType = typeof this._element.getAttribute(&lsquo;data-bs-original-title&rsquo;);</p>
<p>if (title || originalTitleType !== &lsquo;string&rsquo;) {
     this._element.setAttribute(&lsquo;data-bs-original-title&rsquo;, title || &lsquo;&rsquo;);</p>
<pre><code> if (title &amp;&amp; !this._element.getAttribute('aria-label') &amp;&amp; !this._element.textContent) {
   this._element.setAttribute('aria-label', title);
 }

 this._element.setAttribute('title', '');
</code></pre>
<p>}
 }</p>
<p>_enter(event, context) {
   context = this._initializeOnDelegatedTarget(event, context);</p>
<p>if (event) {
     context._activeTrigger[event.type === &lsquo;focusin&rsquo; ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
   }</p>
<p>if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$2) || context._hoverState === HOVER_STATE_SHOW) {
     context._hoverState = HOVER_STATE_SHOW;
     return;
   }</p>
<p>clearTimeout(context._timeout);
   context._hoverState = HOVER_STATE_SHOW;</p>
<p>if (!context._config.delay || !context._config.delay.show) {
     context.show();
     return;
   }</p>
<p>context._timeout = setTimeout(() =&gt; {
     if (context._hoverState === HOVER_STATE_SHOW) {
       context.show();
     }
   }, context._config.delay.show);
 }</p>
<p>_leave(event, context) {
   context = this._initializeOnDelegatedTarget(event, context);</p>
<p>if (event) {
     context._activeTrigger[event.type === &lsquo;focusout&rsquo; ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
   }</p>
<p>if (context._isWithActiveTrigger()) {
     return;
   }</p>
<p>clearTimeout(context._timeout);
   context._hoverState = HOVER_STATE_OUT;</p>
<p>if (!context._config.delay || !context._config.delay.hide) {
     context.hide();
     return;
   }</p>
<p>context._timeout = setTimeout(() =&gt; {
     if (context._hoverState === HOVER_STATE_OUT) {
       context.hide();
     }
   }, context._config.delay.hide);
 }</p>
<p>_isWithActiveTrigger() {
   for (const trigger in this._activeTrigger) {
     if (this._activeTrigger[trigger]) {
       return true;
     }
   }</p>
<p>return false;
 }</p>
<p>_getConfig(config) {
   const dataAttributes = Manipulator.getDataAttributes(this._element);
   Object.keys(dataAttributes).forEach(dataAttr =&gt; {
     if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {
       delete dataAttributes[dataAttr];
     }
   });
   config = { &hellip;this.constructor.Default,
     &hellip;dataAttributes,
     &hellip;(typeof config === &lsquo;object&rsquo; &amp;&amp; config ? config : {})
   };
   config.container = config.container === false ? document.body : getElement(config.container);</p>
<p>if (typeof config.delay === &lsquo;number&rsquo;) {
     config.delay = {
       show: config.delay,
       hide: config.delay
     };
   }</p>
<p>if (typeof config.title === &lsquo;number&rsquo;) {
     config.title = config.title.toString();
   }</p>
<p>if (typeof config.content === &lsquo;number&rsquo;) {
     config.content = config.content.toString();
   }</p>
<p>typeCheckConfig(NAME$4, config, this.constructor.DefaultType);</p>
<p>if (config.sanitize) {
     config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);
   }</p>
<p>return config;
 }</p>
<p>_getDelegateConfig() {
   const config = {};</p>
<p>for (const key in this._config) {
     if (this.constructor.Default[key] !== this._config[key]) {
       config[key] = this._config[key];
     }
   } // In the future can be replaced with:
   // const keysWithDifferentValues = Object.entries(this._config).filter(entry =&gt; this.constructor.Default[entry[0]] !== this._config[entry[0]])
   // <code>Object.fromEntries(keysWithDifferentValues)</code></p>
<p>return config;
 }</p>
<p>_cleanTipClass() {
   const tip = this.getTipElement();
   const basicClassPrefixRegex = new RegExp(<code>(^|\\s)${this._getBasicClassPrefix()}\\S+</code>, &lsquo;g&rsquo;);
   const tabClass = tip.getAttribute(&lsquo;class&rsquo;).match(basicClassPrefixRegex);</p>
<p>if (tabClass !== null &amp;&amp; tabClass.length &gt; 0) {
     tabClass.map(token =&gt; token.trim()).forEach(tClass =&gt; tip.classList.remove(tClass));
   }
 }</p>
<p>_getBasicClassPrefix() {
   return CLASS_PREFIX$1;
 }</p>
<p>_handlePopperPlacementChange(popperData) {
   const {
     state
   } = popperData;</p>
<p>if (!state) {
     return;
   }</p>
<p>this.tip = state.elements.popper;</p>
<p>this._cleanTipClass();</p>
<p>this._addAttachmentClass(this._getAttachment(state.placement));
 }</p>
<p>_disposePopper() {
   if (this._popper) {
     this._popper.destroy();</p>
<pre><code> this._popper = null;
</code></pre>
<p>}
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const data = Tooltip.getOrCreateInstance(this, config);</p>
<pre><code> if (typeof config === 'string') {
   if (typeof data[config] === 'undefined') {
     throw new TypeError(`No method named "${config}"`);
   }

   data[config]();
 }
</code></pre>
<p>});
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-60'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-60'>#</a>
      </div>
      <p>defineJQueryPlugin(Tooltip);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Data</span> <span class="nx">Api</span> <span class="nx">implementation</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-61'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-61'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Tab</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-62'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-62'>#</a>
      </div>
      <p>const NAME$3 = &lsquo;popover&rsquo;;
  const DATA_KEY$3 = &lsquo;bs.popover&rsquo;;
  const EVENT_KEY$3 = <code>.${DATA_KEY$3}</code>;
  const CLASS_PREFIX = &lsquo;bs-popover&rsquo;;
  const Default$2 = { &hellip;Tooltip.Default,
 placement: &lsquo;right&rsquo;,
 offset: [0, 8],
 trigger: &lsquo;click&rsquo;,
 content: &lsquo;&rsquo;,
 template: &lsquo;<div class="popover" role="tooltip">&lsquo; + &lsquo;<div class="popover-arrow"></div>&lsquo; + &lsquo;<h3 class="popover-header"></h3>&lsquo; + &lsquo;<div class="popover-body"></div>&lsquo; + &lsquo;</div>&lsquo;
  };
  const DefaultType$2 = { &hellip;Tooltip.DefaultType,
 content: &lsquo;(string|element|function)&rsquo;
  };
  const Event$1 = {
 HIDE: <code>hide${EVENT_KEY$3}</code>,
 HIDDEN: <code>hidden${EVENT_KEY$3}</code>,
 SHOW: <code>show${EVENT_KEY$3}</code>,
 SHOWN: <code>shown${EVENT_KEY$3}</code>,
 INSERTED: <code>inserted${EVENT_KEY$3}</code>,
 CLICK: <code>click${EVENT_KEY$3}</code>,
 FOCUSIN: <code>focusin${EVENT_KEY$3}</code>,
 FOCUSOUT: <code>focusout${EVENT_KEY$3}</code>,
 MOUSEENTER: <code>mouseenter${EVENT_KEY$3}</code>,
 MOUSELEAVE: <code>mouseleave${EVENT_KEY$3}</code>
  };
  const SELECTOR_TITLE = &lsquo;.popover-header&rsquo;;
  const SELECTOR_CONTENT = &lsquo;.popover-body&rsquo;;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">toast</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-63'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-63'>#</a>
      </div>
      <p>class Popover extends Tooltip {
 // Getters
 static get Default() {
   return Default$2;
 }</p>
<p>static get NAME() {
   return NAME$3;
 }</p>
<p>static get Event() {
   return Event$1;
 }</p>
<p>static get DefaultType() {
   return DefaultType$2;
 } // Overrides</p>
<p>isWithContent() {
   return this.getTitle() || this._getContent();
 }</p>
<p>setContent(tip) {
   this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TITLE);</p>
<p>this._sanitizeAndSetContent(tip, this._getContent(), SELECTOR_CONTENT);
 } // Private</p>
<p>_getContent() {
   return this._resolvePossibleFunction(this._config.content);
 }</p>
<p>_getBasicClassPrefix() {
   return CLASS_PREFIX;
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const data = Popover.getOrCreateInstance(this, config);</p>
<pre><code> if (typeof config === 'string') {
   if (typeof data[config] === 'undefined') {
     throw new TypeError(`No method named "${config}"`);
   }

   data[config]();
 }
</code></pre>
<p>});
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Constants</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-64'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-64'>#</a>
      </div>
      <p>defineJQueryPlugin(Popover);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Class</span> <span class="nx">Definition</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-65'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-65'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">jQuery</span>
   <span class="o">*</span> <span class="o">------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">add</span> <span class="p">.</span><span class="nx">Toast</span> <span class="nx">to</span> <span class="nx">jQuery</span> <span class="nx">only</span> <span class="k">if</span> <span class="nx">jQuery</span> <span class="nx">is</span> <span class="nx">present</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-66'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-66'>#</a>
      </div>
      <p>const NAME$2 = &lsquo;scrollspy&rsquo;;
  const DATA_KEY$2 = &lsquo;bs.scrollspy&rsquo;;
  const EVENT_KEY$2 = <code>.${DATA_KEY$2}</code>;
  const DATA_API_KEY$1 = &lsquo;.data-api&rsquo;;
  const Default$1 = {
 offset: 10,
 method: &lsquo;auto&rsquo;,
 target: &lsquo;&rsquo;
  };
  const DefaultType$1 = {
 offset: &lsquo;number&rsquo;,
 method: &lsquo;string&rsquo;,
 target: &lsquo;(string|element)&rsquo;
  };
  const EVENT_ACTIVATE = <code>activate${EVENT_KEY$2}</code>;
  const EVENT_SCROLL = <code>scroll${EVENT_KEY$2}</code>;
  const EVENT_LOAD_DATA_API = <code>load${EVENT_KEY$2}${DATA_API_KEY$1}</code>;
  const CLASS_NAME_DROPDOWN_ITEM = &lsquo;dropdown-item&rsquo;;
  const CLASS_NAME_ACTIVE$1 = &lsquo;active&rsquo;;
  const SELECTOR_DATA_SPY = &lsquo;[data-bs-spy=&rdquo;scroll&rdquo;]&rsquo;;
  const SELECTOR_NAV_LIST_GROUP$1 = &lsquo;.nav, .list-group&rsquo;;
  const SELECTOR_NAV_LINKS = &lsquo;.nav-link&rsquo;;
  const SELECTOR_NAV_ITEMS = &lsquo;.nav-item&rsquo;;
  const SELECTOR_LIST_ITEMS = &lsquo;.list-group-item&rsquo;;
  const SELECTOR_LINK_ITEMS = <code>${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}, .${CLASS_NAME_DROPDOWN_ITEM}</code>;
  const SELECTOR_DROPDOWN$1 = &lsquo;.dropdown&rsquo;;
  const SELECTOR_DROPDOWN_TOGGLE$1 = &lsquo;.dropdown-toggle&rsquo;;
  const METHOD_OFFSET = &lsquo;offset&rsquo;;
  const METHOD_POSITION = &lsquo;position&rsquo;;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span>
   <span class="o">*</span> <span class="nx">Bootstrap</span> <span class="p">(</span><span class="nx">v5</span><span class="mf">.1.3</span><span class="p">)</span><span class="o">:</span> <span class="nx">index</span><span class="p">.</span><span class="nx">umd</span><span class="p">.</span><span class="nx">js</span>
   <span class="o">*</span> <span class="nx">Licensed</span> <span class="nx">under</span> <span class="nx">MIT</span> <span class="p">(</span><span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/twbs/bootstrap/blob/main/LICENSE)</span>
   <span class="o">*</span> <span class="o">--------------------------------------------------------------------------</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-67'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-67'>#</a>
      </div>
      <p>class ScrollSpy extends BaseComponent {
 constructor(element, config) {
   super(element);
   this._scrollElement = this._element.tagName === &lsquo;BODY&rsquo; ? window : this._element;
   this._config = this._getConfig(config);
   this._offsets = [];
   this._targets = [];
   this._activeTarget = null;
   this._scrollHeight = 0;
   EventHandler.on(this._scrollElement, EVENT_SCROLL, () =&gt; this._process());
   this.refresh();</p>
<p>this._process();
 } // Getters</p>
<p>static get Default() {
   return Default$1;
 }</p>
<p>static get NAME() {
   return NAME$2;
 } // Public</p>
<p>refresh() {
   const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
   const offsetMethod = this._config.method === &lsquo;auto&rsquo; ? autoMethod : this._config.method;
   const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
   this._offsets = [];
   this._targets = [];
   this._scrollHeight = this._getScrollHeight();
   const targets = SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target);
   targets.map(element =&gt; {
     const targetSelector = getSelectorFromElement(element);
     const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;</p>
<pre><code> if (target) {
   const targetBCR = target.getBoundingClientRect();

   if (targetBCR.width || targetBCR.height) {
     return [Manipulator[offsetMethod](target).top + offsetBase, targetSelector];
   }
 }

 return null;
</code></pre>
<p>}).filter(item =&gt; item).sort((a, b) =&gt; a[0] - b[0]).forEach(item =&gt; {
     this._offsets.push(item[0]);</p>
<pre><code> this._targets.push(item[1]);
</code></pre>
<p>});
 }</p>
<p>dispose() {
   EventHandler.off(this._scrollElement, EVENT_KEY$2);
   super.dispose();
 } // Private</p>
<p>_getConfig(config) {
   config = { &hellip;Default$1,
     &hellip;Manipulator.getDataAttributes(this._element),
     &hellip;(typeof config === &lsquo;object&rsquo; &amp;&amp; config ? config : {})
   };
   config.target = getElement(config.target) || document.documentElement;
   typeCheckConfig(NAME$2, config, DefaultType$1);
   return config;
 }</p>
<p>_getScrollTop() {
   return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
 }</p>
<p>_getScrollHeight() {
   return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
 }</p>
<p>_getOffsetHeight() {
   return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
 }</p>
<p>_process() {
   const scrollTop = this._getScrollTop() + this._config.offset;</p>
<p>const scrollHeight = this._getScrollHeight();</p>
<p>const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();</p>
<p>if (this._scrollHeight !== scrollHeight) {
     this.refresh();
   }</p>
<p>if (scrollTop &gt;= maxScroll) {
     const target = this._targets[this._targets.length - 1];</p>
<pre><code> if (this._activeTarget !== target) {
   this._activate(target);
 }

 return;
</code></pre>
<p>}</p>
<p>if (this._activeTarget &amp;&amp; scrollTop &lt; this._offsets[0] &amp;&amp; this._offsets[0] &gt; 0) {
     this._activeTarget = null;</p>
<pre><code> this._clear();

 return;
</code></pre>
<p>}</p>
<p>for (let i = this._offsets.length; i&ndash;;) {
     const isActiveTarget = this._activeTarget !== this._targets[i] &amp;&amp; scrollTop &gt;= this._offsets[i] &amp;&amp; (typeof this._offsets[i + 1] === &lsquo;undefined&rsquo; || scrollTop &lt; this._offsets[i + 1]);</p>
<pre><code> if (isActiveTarget) {
   this._activate(this._targets[i]);
 }
</code></pre>
<p>}
 }</p>
<p>_activate(target) {
   this._activeTarget = target;</p>
<p>this._clear();</p>
<p>const queries = SELECTOR_LINK_ITEMS.split(&lsquo;,&rsquo;).map(selector =&gt; <code>${selector}[data-bs-target="${target}"],${selector}[href="${target}"]</code>);
   const link = SelectorEngine.findOne(queries.join(&lsquo;,&rsquo;), this._config.target);
   link.classList.add(CLASS_NAME_ACTIVE$1);</p>
<p>if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
     SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);
   } else {
     SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach(listGroup =&gt; {
       // Set triggered links parents as active
       // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
       SelectorEngine.prev(listGroup, <code>${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}</code>).forEach(item =&gt; item.classList.add(CLASS_NAME_ACTIVE$1)); // Handle special case when .nav-link is inside .nav-item</p>
<pre><code>   SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach(navItem =&gt; {
     SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach(item =&gt; item.classList.add(CLASS_NAME_ACTIVE$1));
   });
 });
</code></pre>
<p>}</p>
<p>EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {
     relatedTarget: target
   });
 }</p>
<p>_clear() {
   SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target).filter(node =&gt; node.classList.contains(CLASS_NAME_ACTIVE$1)).forEach(node =&gt; node.classList.remove(CLASS_NAME_ACTIVE$1));
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const data = ScrollSpy.getOrCreateInstance(this, config);</p>
<pre><code> if (typeof config !== 'string') {
   return;
 }

 if (typeof data[config] === 'undefined') {
   throw new TypeError(`No method named "${config}"`);
 }

 data[config]();
</code></pre>
<p>});
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-68'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-68'>#</a>
      </div>
      <p>EventHandler.on(window, EVENT_LOAD_DATA_API, () =&gt; {
 SelectorEngine.find(SELECTOR_DATA_SPY).forEach(spy =&gt; new ScrollSpy(spy));
  });
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-69'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-69'>#</a>
      </div>
      <p>defineJQueryPlugin(ScrollSpy);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-70'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-70'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-71'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-71'>#</a>
      </div>
      <p>const NAME$1 = &lsquo;tab&rsquo;;
  const DATA_KEY$1 = &lsquo;bs.tab&rsquo;;
  const EVENT_KEY$1 = <code>.${DATA_KEY$1}</code>;
  const DATA_API_KEY = &lsquo;.data-api&rsquo;;
  const EVENT_HIDE$1 = <code>hide${EVENT_KEY$1}</code>;
  const EVENT_HIDDEN$1 = <code>hidden${EVENT_KEY$1}</code>;
  const EVENT_SHOW$1 = <code>show${EVENT_KEY$1}</code>;
  const EVENT_SHOWN$1 = <code>shown${EVENT_KEY$1}</code>;
  const EVENT_CLICK_DATA_API = <code>click${EVENT_KEY$1}${DATA_API_KEY}</code>;
  const CLASS_NAME_DROPDOWN_MENU = &lsquo;dropdown-menu&rsquo;;
  const CLASS_NAME_ACTIVE = &lsquo;active&rsquo;;
  const CLASS_NAME_FADE$1 = &lsquo;fade&rsquo;;
  const CLASS_NAME_SHOW$1 = &lsquo;show&rsquo;;
  const SELECTOR_DROPDOWN = &lsquo;.dropdown&rsquo;;
  const SELECTOR_NAV_LIST_GROUP = &lsquo;.nav, .list-group&rsquo;;
  const SELECTOR_ACTIVE = &lsquo;.active&rsquo;;
  const SELECTOR_ACTIVE_UL = &lsquo;:scope &gt; li &gt; .active&rsquo;;
  const SELECTOR_DATA_TOGGLE = &lsquo;[data-bs-toggle=&rdquo;tab&rdquo;], [data-bs-toggle=&rdquo;pill&rdquo;], [data-bs-toggle=&rdquo;list&rdquo;]&rsquo;;
  const SELECTOR_DROPDOWN_TOGGLE = &lsquo;.dropdown-toggle&rsquo;;
  const SELECTOR_DROPDOWN_ACTIVE_CHILD = &lsquo;:scope &gt; .dropdown-menu .active&rsquo;;
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-72'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-72'>#</a>
      </div>
      <p>class Tab extends BaseComponent {
 // Getters
 static get NAME() {
   return NAME$1;
 } // Public</p>
<p>show() {
   if (this._element.parentNode &amp;&amp; this._element.parentNode.nodeType === Node.ELEMENT_NODE &amp;&amp; this._element.classList.contains(CLASS_NAME_ACTIVE)) {
     return;
   }</p>
<p>let previous;
   const target = getElementFromSelector(this._element);</p>
<p>const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);</p>
<p>if (listElement) {
     const itemSelector = listElement.nodeName === &lsquo;UL&rsquo; || listElement.nodeName === &lsquo;OL&rsquo; ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
     previous = SelectorEngine.find(itemSelector, listElement);
     previous = previous[previous.length - 1];
   }</p>
<p>const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {
     relatedTarget: this._element
   }) : null;
   const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {
     relatedTarget: previous
   });</p>
<p>if (showEvent.defaultPrevented || hideEvent !== null &amp;&amp; hideEvent.defaultPrevented) {
     return;
   }</p>
<p>this._activate(this._element, listElement);</p>
<p>const complete = () =&gt; {
     EventHandler.trigger(previous, EVENT_HIDDEN$1, {
       relatedTarget: this._element
     });
     EventHandler.trigger(this._element, EVENT_SHOWN$1, {
       relatedTarget: previous
     });
   };</p>
<p>if (target) {
     this._activate(target, target.parentNode, complete);
   } else {
     complete();
   }
 } // Private</p>
<p>_activate(element, container, callback) {
   const activeElements = container &amp;&amp; (container.nodeName === &lsquo;UL&rsquo; || container.nodeName === &lsquo;OL&rsquo;) ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);
   const active = activeElements[0];
   const isTransitioning = callback &amp;&amp; active &amp;&amp; active.classList.contains(CLASS_NAME_FADE$1);</p>
<p>const complete = () =&gt; this._transitionComplete(element, active, callback);</p>
<p>if (active &amp;&amp; isTransitioning) {
     active.classList.remove(CLASS_NAME_SHOW$1);</p>
<pre><code> this._queueCallback(complete, element, true);
</code></pre>
<p>} else {
     complete();
   }
 }</p>
<p>_transitionComplete(element, active, callback) {
   if (active) {
     active.classList.remove(CLASS_NAME_ACTIVE);
     const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);</p>
<pre><code> if (dropdownChild) {
   dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
 }

 if (active.getAttribute('role') === 'tab') {
   active.setAttribute('aria-selected', false);
 }
</code></pre>
<p>}</p>
<p>element.classList.add(CLASS_NAME_ACTIVE);</p>
<p>if (element.getAttribute(&lsquo;role&rsquo;) === &lsquo;tab&rsquo;) {
     element.setAttribute(&lsquo;aria-selected&rsquo;, true);
   }</p>
<p>reflow(element);</p>
<p>if (element.classList.contains(CLASS_NAME_FADE$1)) {
     element.classList.add(CLASS_NAME_SHOW$1);
   }</p>
<p>let parent = element.parentNode;</p>
<p>if (parent &amp;&amp; parent.nodeName === &lsquo;LI&rsquo;) {
     parent = parent.parentNode;
   }</p>
<p>if (parent &amp;&amp; parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
     const dropdownElement = element.closest(SELECTOR_DROPDOWN);</p>
<pre><code> if (dropdownElement) {
   SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(dropdown =&gt; dropdown.classList.add(CLASS_NAME_ACTIVE));
 }

 element.setAttribute('aria-expanded', true);
</code></pre>
<p>}</p>
<p>if (callback) {
     callback();
   }
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const data = Tab.getOrCreateInstance(this);</p>
<pre><code> if (typeof config === 'string') {
   if (typeof data[config] === 'undefined') {
     throw new TypeError(`No method named "${config}"`);
   }

   data[config]();
 }
</code></pre>
<p>});
 }</p>
<p>}
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-73'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-73'>#</a>
      </div>
      <p>EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
 if ([&lsquo;A&rsquo;, &lsquo;AREA&rsquo;].includes(this.tagName)) {
   event.preventDefault();
 }</p>
<p>if (isDisabled(this)) {
   return;
 }</p>
<p>const data = Tab.getOrCreateInstance(this);
 data.show();
  });
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-74'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-74'>#</a>
      </div>
      <p>defineJQueryPlugin(Tab);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-75'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-75'>#</a>
      </div>
      <p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-76'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-76'>#</a>
      </div>
      <p>const NAME = &lsquo;toast&rsquo;;
  const DATA_KEY = &lsquo;bs.toast&rsquo;;
  const EVENT_KEY = <code>.${DATA_KEY}</code>;
  const EVENT_MOUSEOVER = <code>mouseover${EVENT_KEY}</code>;
  const EVENT_MOUSEOUT = <code>mouseout${EVENT_KEY}</code>;
  const EVENT_FOCUSIN = <code>focusin${EVENT_KEY}</code>;
  const EVENT_FOCUSOUT = <code>focusout${EVENT_KEY}</code>;
  const EVENT_HIDE = <code>hide${EVENT_KEY}</code>;
  const EVENT_HIDDEN = <code>hidden${EVENT_KEY}</code>;
  const EVENT_SHOW = <code>show${EVENT_KEY}</code>;
  const EVENT_SHOWN = <code>shown${EVENT_KEY}</code>;
  const CLASS_NAME_FADE = &lsquo;fade&rsquo;;
  const CLASS_NAME_HIDE = &lsquo;hide&rsquo;; // @deprecated - kept here only for backwards compatibility</p>
<p>const CLASS_NAME_SHOW = &lsquo;show&rsquo;;
  const CLASS_NAME_SHOWING = &lsquo;showing&rsquo;;
  const DefaultType = {
 animation: &lsquo;boolean&rsquo;,
 autohide: &lsquo;boolean&rsquo;,
 delay: &lsquo;number&rsquo;
  };
  const Default = {
 animation: true,
 autohide: true,
 delay: 5000
  };
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-77'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-77'>#</a>
      </div>
      <p>class Toast extends BaseComponent {
 constructor(element, config) {
   super(element);
   this._config = this._getConfig(config);
   this._timeout = null;
   this._hasMouseInteraction = false;
   this._hasKeyboardInteraction = false;</p>
<p>this._setListeners();
 } // Getters</p>
<p>static get DefaultType() {
   return DefaultType;
 }</p>
<p>static get Default() {
   return Default;
 }</p>
<p>static get NAME() {
   return NAME;
 } // Public</p>
<p>show() {
   const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);</p>
<p>if (showEvent.defaultPrevented) {
     return;
   }</p>
<p>this._clearTimeout();</p>
<p>if (this._config.animation) {
     this._element.classList.add(CLASS_NAME_FADE);
   }</p>
<p>const complete = () =&gt; {
     this._element.classList.remove(CLASS_NAME_SHOWING);</p>
<pre><code> EventHandler.trigger(this._element, EVENT_SHOWN);

 this._maybeScheduleHide();
</code></pre>
<p>};</p>
<p>this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated</p>
<p>reflow(this._element);</p>
<p>this._element.classList.add(CLASS_NAME_SHOW);</p>
<p>this._element.classList.add(CLASS_NAME_SHOWING);</p>
<p>this._queueCallback(complete, this._element, this._config.animation);
 }</p>
<p>hide() {
   if (!this._element.classList.contains(CLASS_NAME_SHOW)) {
     return;
   }</p>
<p>const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);</p>
<p>if (hideEvent.defaultPrevented) {
     return;
   }</p>
<p>const complete = () =&gt; {
     this._element.classList.add(CLASS_NAME_HIDE); // @deprecated</p>
<pre><code> this._element.classList.remove(CLASS_NAME_SHOWING);

 this._element.classList.remove(CLASS_NAME_SHOW);

 EventHandler.trigger(this._element, EVENT_HIDDEN);
</code></pre>
<p>};</p>
<p>this._element.classList.add(CLASS_NAME_SHOWING);</p>
<p>this._queueCallback(complete, this._element, this._config.animation);
 }</p>
<p>dispose() {
   this._clearTimeout();</p>
<p>if (this._element.classList.contains(CLASS_NAME_SHOW)) {
     this._element.classList.remove(CLASS_NAME_SHOW);
   }</p>
<p>super.dispose();
 } // Private</p>
<p>_getConfig(config) {
   config = { &hellip;Default,
     &hellip;Manipulator.getDataAttributes(this._element),
     &hellip;(typeof config === &lsquo;object&rsquo; &amp;&amp; config ? config : {})
   };
   typeCheckConfig(NAME, config, this.constructor.DefaultType);
   return config;
 }</p>
<p>_maybeScheduleHide() {
   if (!this._config.autohide) {
     return;
   }</p>
<p>if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
     return;
   }</p>
<p>this._timeout = setTimeout(() =&gt; {
     this.hide();
   }, this._config.delay);
 }</p>
<p>_onInteraction(event, isInteracting) {
   switch (event.type) {
     case &lsquo;mouseover&rsquo;:
     case &lsquo;mouseout&rsquo;:
       this._hasMouseInteraction = isInteracting;
       break;</p>
<pre><code> case 'focusin':
 case 'focusout':
   this._hasKeyboardInteraction = isInteracting;
   break;
</code></pre>
<p>}</p>
<p>if (isInteracting) {
     this._clearTimeout();</p>
<pre><code> return;
</code></pre>
<p>}</p>
<p>const nextElement = event.relatedTarget;</p>
<p>if (this._element === nextElement || this._element.contains(nextElement)) {
     return;
   }</p>
<p>this._maybeScheduleHide();
 }</p>
<p>_setListeners() {
   EventHandler.on(this._element, EVENT_MOUSEOVER, event =&gt; this._onInteraction(event, true));
   EventHandler.on(this._element, EVENT_MOUSEOUT, event =&gt; this._onInteraction(event, false));
   EventHandler.on(this._element, EVENT_FOCUSIN, event =&gt; this._onInteraction(event, true));
   EventHandler.on(this._element, EVENT_FOCUSOUT, event =&gt; this._onInteraction(event, false));
 }</p>
<p>_clearTimeout() {
   clearTimeout(this._timeout);
   this._timeout = null;
 } // Static</p>
<p>static jQueryInterface(config) {
   return this.each(function () {
     const data = Toast.getOrCreateInstance(this, config);</p>
<pre><code> if (typeof config === 'string') {
   if (typeof data[config] === 'undefined') {
     throw new TypeError(`No method named "${config}"`);
   }

   data[config](this);
 }
</code></pre>
<p>});
 }</p>
<p>}</p>
<p>enableDismissTrigger(Toast);
*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-78'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-78'>#</a>
      </div>
      <p>defineJQueryPlugin(Toast);</p>
<p>*</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-79'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-79'>#</a>
      </div>
      <p>const index_umd = {
 Alert,
 Button,
 Carousel,
 Collapse,
 Dropdown,
 Modal,
 Offcanvas,
 Popover,
 ScrollSpy,
 Tab,
 Toast,
 Tooltip
  };</p>
<p>return index_umd;</p>
<p>}));
//# sourceMappingURL=bootstrap.bundle.js.map</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>
